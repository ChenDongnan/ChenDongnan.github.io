<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS UI性能调优]]></title>
    <url>%2F2018%2F11%2F21%2FiOS%20UI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[趁着项目的短暂的空闲期，把最近关于iOS图形渲染优化的一些方法和经验记录在这里，也算是一个学习的总结，如果有帮助到读者的话就再好不过了。 基础知识其实网上关于iOS渲染机制的文章也是数不胜数，这里推荐几篇大牛的文章给大家参考学习，相信大家在看完后会对iOS渲染机制有更加深刻的理解，本文也就不再赘述这方面的知识。同时也非常推荐iOS Core Animation advanced techniques这本书，阅读之后受益匪浅。 iOS 开发：绘制像素到屏幕https://segmentfault.com/a/1190000000390012 深入理解 iOS Rendering Process https://juejin.im/post/5ad3f1cc6fb9a028d9379c5f?utm_source=gold_browser_extension 性能检测既然要进行优化，那么首先需要做的就是检测我们项目中当前的性能状况，苹果的Xcode自带的Instrument就可以很好的完成这项工作，使用方法也很简单。这里以最新版Xcode10为例子,点击Xcode-&gt;Open Developer Tool -&gt;Instruments，启动Instruments, 如下图，点击Core Animation模块会出现如下面板，在All Processes这里可以选择你想要测试的项目这里我选择了公司的项目，然后点击左上角的红圈，instrument就运行了，你会发现你手机上安装的该项目也会随之运行起来。然后就会出现上图，显示的是项目运行的FPS,以及GPU的利用率。当画面静止的时候，FPS为0。一般来说，FPS应当要大于45才不会显得卡顿。 影响FPS的因素是多样的, 这里我们只考虑UI方面的因素，我们可以在Xcode10工具栏的Debug -&gt; View Debugging -&gt; Rendering进行查看可以看到这里有很多Debug选项, 我们来看几个比较重要的 Color Blended Layers图层混色，就是多个视图的位置有重叠，视图本身又有透明度。重叠区域的每一个像素，GPU 需要算出一种新的颜色（混色）。混合计算的公式是：1234567891011121314贴一个苹果文档中的解释&gt;```objective-c&gt;The blend mode constants introduced in OS X v10.5 represent the Porter-Duff blend modes. The symbols in the equations for these blend modes are:&gt;&gt; * R is the premultiplied result&gt;&gt; * S is the source color, and includes alpha&gt;&gt; * D is the destination color, and includes alpha&gt;&gt; * Ra, Sa, and Da are the alpha components of R, S, and D&gt; R是结果色，S是包含透明度的源色，D是包含透明度的目标色，Sa是原色的透明度 如下图，绿色代表没有发生图层混色，红色代表发生了图层混色。图中的label2设置了alpha为0.5，因此触发了Color Blended; 我们通过给View设置一个不透明的背景色，来避免图层混色的发生。 关于Color Blended Layers有几个注意点 如果label中的内容包含中文，label实际渲染区域要大于label的size，最外层会多一个subLayer，所以即使设置背景色不透明，仍然会发生混色。因此，还需要添加masksToBounds = YES UIImageView不仅需要自身容器不透明，并且imageView包含的内容图片也必须是不透明的 如果使用的是CALayer，要把opaque属性设置成YES(默认是NO)。如果是用的UIView, opaque属性默认是YES。 Color Hits Green and Misses Red 这个选项是用来检测图像是否有光栅化(Rasterize)的，这个概念听起来是一头雾水，百度之; 光栅化即将矢量图形转化为位图（栅格图像） , Calayer有一个属性shouldRasterize，就是用来决定是否开启光栅化的。 放一个苹果的文档 1When true, the layer is rendered as a bitmap in its local coordinate space (&quot;rasterized&quot;), then the bitmap is composited into the destination (with the minificationFilter and magnificationFilter properties of the layer applied if the bitmap needs scaling). Rasterization occurs after the layer&apos;s filters and shadow effects are applied, but before the opacity modulation. As an implementation detail the rendering engine may attempt to cache and reuse the bitmap from one frame to the next. (Whether it does or not will have no affect on the rendered output.) When false the layer is composited directly into the destination whenever possible (however, certain features of the compositing model may force rasterization, e.g. adding filters). Defaults to NO. 当这个属性被设置为YES时，即开启了光栅化。它会将一个layer预先渲染成bitmap再加入到缓存中，layer的阴影等效果也会被保存到bitmap中，光栅化后会将图层绘制到一个屏幕外的图像，然后这个图像将会被缓存起来并绘制到实际图层的 contents 和子图层，对于有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧来更加高效。但是光栅化原始图像需要时间，而且会消耗额外的内存。 当我们开启光栅化后,需要注意几点问题： 如果我们更新已光栅化的layer,会造成大量的离屏渲染。 CALayer的光栅化选项的开启与否需要我们仔细衡量使用场景。它主要适用于设置阴影耗费资源比较多的静态内容，而对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费。例如TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可栅格化。则会造成大量的offscreen渲染,降低图形性能。 不要过度使用,系统限制了缓存的大小为2.5X Screen Size. 如果过度使用,超出缓存之后,同样会造成大量的offscreen渲染。 被光栅化的图片如果超过100ms没有被使用,则会被移除。 因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。 Color Offscreen-Rendered Yellow 离屏渲染 离屏渲染应该是经常听到的一次词了，简单来说就是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作，由于过程中需要切换context，性能消耗比较大。 CoreGraphics的上下文绘制，drawRect绘制，layer圆角/边框/阴影/抗锯齿/光栅化等都可能导致离屏渲染 (Core Graphics 的绘制API出发的离屏渲染不是那种GPU的离屏渲染，使用Core Graphics 绘制 API 是在 CPU 上执行，触发的是 CPU 的离屏渲染。) 在Debug选项中选中Color Offscreen-Rendered Yellow,就可以检测视图的离屏渲染情况。如下图所示，呈现黄色的部分为发生了离屏渲染。 经过真机测试，发现以下情况 在iOS9系统上, 对UIImageView/UILabel/Button,使用cornerRadius + masksToBounds/ClipToBounds会发生离屏渲染, 但是对于UIButton,只需要设置cornerRadius就可以实现圆角效果，不会发生离屏渲染。 在iOS11上, 对UIImageView/UILabel,使用cornerRadius + masksToBounds/ClipToBounds并不会触发离屏渲染，但是在设置了shadow之后会触发离屏渲染。 在查找了网上的一些资料后，了解到苹果在iOS9之后做了优化，减少了不必要的离屏渲染。 针设置圆角/阴影导致的离屏渲染的处理方式 如果方便的情况下，可以让设计师直接提供裁切好圆角的图片。 对于UIView，只设置CornerRadius,无需设置ClipToBounds就可以实现圆角效果，不会触发离屏渲染。 对于UILabel，只设置CornerRadius,无需设置ClipToBounds就可以实现圆角效果，不会触发离屏渲染；如果label有背景色，在iOS10以上系统，可以使用CornerRadius + ClipToBounds组合，10以下的系统，可以设置label.layer.backgroundColor来代替label.backgroundColor 对于UIImageView 如果只需要支持iOS10及更新版本的机型，那么大胆的使用cornerRadius + masksToBounds，不会触发离屏渲染； 10以下的机型，可以通过给UIImage添加Category，利用UIBezierPath来实现。 12345678910111213- (UIImage*)imageAddCornerWithRadius:(CGFloat)radius andSize:(CGSize)size&#123; CGRect rect = CGRectMake(0, 0, size.width, size.height); UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale); CGContextRef ctx = UIGraphicsGetCurrentContext(); UIBezierPath * path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)]; CGContextAddPath(ctx,path.CGPath); CGContextClip(ctx); [self drawInRect:rect]; CGContextDrawPath(ctx, kCGPathFillStroke); UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; ​ 对于UIButton，如果只需要实现文字 + 圆角效果，那么用ConerRadius就可以了；如果要实现有图片的Button的圆角效果, 可以先参照上述方法先对图片进行处理。 对于简单阴影，可以使用CGContexRef/UIBezierPath绘制阴影路径并设置给ShadowPath来代替shadowOffset等属性设置阴影，下面是关于shadowPath的官方解释 12345imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0;imageView.layer.shadowRadius = 2.0;UIBezierPath *path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 以上就是对于UI的一些性能优化方法。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目启动时间优化]]></title>
    <url>%2F2017%2F12%2F22%2Fstart-time%2F</url>
    <content type="text"><![CDATA[App的启动时间是影响用户体验的一大因素，整理了一些关于App启动时间优化的方法，并结合我们自己的项目实践，记录在这里。 App启动过程首先需要知道当我们点击手机屏幕上App的图标，到App的首页呈现在面前，系统经历了怎样的过程。这里以main函数为分界，将启动过程分成main函数前和main函数后两个阶段,，这两部分的时间分别用T1和T2来表示。 T1所包含的时间 ####加载可执行文件（.o文件）#### Mach-O 是OSX系统的可执行文件,它的文件格式如下 它包含三分的内容 Header，指明了目标架构、文件类型、Load Commands个数等基本信息 Load Commands， 描述文件在虚拟内存中的逻辑与布局。在Mach-O文件中可以有多个Segment, 每个Segment可能包含一个或多个Section。 Data，Segment的具体数据，包含了代码和数据等 想了解关于Mach-O更加详细内容的，可以参考下面两篇文章 系统加载完可执行文件后，通过分析文件来获得dyld所在路径来加载dyld (the dynamic link editor 动态链接器)。接下来就由Dyld进行动态链接了。 Dyld的整个流程如下： Load dylibs从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap()。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。 Fix-ups在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。 现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 __DATA 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。 所以 dyld 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。 Rebasing&amp;BindingRebasing 在过去，dylib会被加载到指定地址，所有指针和数据对于代码来说都是正确的，如今由于ASLR的存在，可执行文件和动态链接库在内存中的加载地址是不固定的，dylib会被加载到新的随机地址上(actual_address)，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有偏差，dyld需要修正这个偏差(slide)，做法就是将dylib内部的指针地址都加上这个偏移量，偏移量的计算方法如下： Slide = actual_address - preferred_address ASLR (Address Space Layout Randomization): 地址空间布局随机化，镜像会在随机的地址上加载。 传统方式下，进程每次启动采用的都是固定可遇见的方式，这意味着一个给定的程序在给定的架构上的进程初始虚拟内存都是基本一致的，而且在进程正常运行的生命周期中，内存中的地址分布具有很强的可预测性，给了黑客可乘之机。 如果采用ASLR，进程每次启动、地址都会被简单地随机化，但是只是偏移，不是搅乱。大体布局—程序文本、数据和库是一样的，但是具体的地址都不同了，可以阻挡黑客对地址的猜测。 Binding 将指针指向镜像外部的内容，binding就是将这个二进制调用的外部符号进行绑定的过程。比如我们objc代码中需要使用到NSObject, 即符号_OBJC_CLASS_$_NSObject，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework 中，因此就需要binding这个操作将对应关系绑定到一起； Binding处理那些只指向dylib外部的指针，他们实际上被符号(symbol)名称绑定。dyld需要找到symbol对应的实现。这需要很多计算，去符号表里查找。找到后会将内容存储到 __DATA 段中的那个指针中。Binding 看起来计算量比 Rebasing 更大，但其实需要的 I/O 操作很少，Binding的时间主要是耗费在计算上，因为IO操作之前 Rebasing 已经替 Binding 做过了，所以这两个步骤的耗时是混在一起的。 ####Objc Setup#### 这一步的主要工作是： 读取二进制文件的DATA段内容，找到与objc相关信息。 注册Objc类 (class registration)，OC runtime 需要维护一张映射类名与类的全局表。当加载一个dylib时，其定义的所有的类都需要被注册到这个全局表中。 把category的定义插入方法列表 (category registration) 确保每一个selector唯一（selector uniquing） ####Initializers#### 以上三步属于静态调整, 都是在修改__DATA segment中的内容，而这一步开始则是动态调整，开始在堆栈中写入内容。 Objc的+load()函数 C++的构造函数属性函数 最后 dyld 会调用 main() 函数。main() 会调用 UIApplicationMain()。 如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点，这就分别是热启动和冷启动的概念 T2所包含的时间 didFinishLauchWithOptions方法 第一个页面渲染的时间 启动时间测量苹果官方建议我们要在最低支持机型上测量启动时间，我们的项目支持iPhone5及以上机型安装。但是公司只有5s的测试机，所以我暂且拿5s来进行测量。并且在这里冷启动才是我们要重点关注的，所以要先把手机重启来测量app的冷启动时间。 这里我们也要分为T1和T2来分别测量，对于T1，我们只需在Xcode-&gt;Project-&gt;Scheme-&gt;Edit Scheme 找到 Run -&gt; Enviroment Variables, 添加并勾选DYLD_PRINTT_STATISTICS环境变量就可以测量了。 对于T2部分，我们使用在main()，didFinishLaunchingWithOptions以及一个页面的viewDidAppear中进行记录，从而来计算T2的时间。 #define TICK NSDate *startTime = [NSDate date] define TOCK NSLog(@&quot;------------Time Cost: %f\n[文件名:%s]\n&quot;&quot;[函数名:%s]\n&quot;&quot;[行号:%d]\n-----------&quot;, [startTime timeIntervalSinceNow], __FILE__, __FUNCTION__, __LINE__) 这里定义了两个宏来记录每个函数的耗时, 在每个要统计的函数头尾分别加上这两个宏，就可以计算出函数耗时。 运行之后，可以看到pre-main的耗时是437.28ms，也就是T1,和苹果建议的400ms很接近了，不过还有优化空间。 didFinishLaunchingWithOptions的耗时为4.475018秒。 项目中的优化实践T1的优化其实App启动过程中每一个步骤都会影响启动性能，但是有些部分所消耗的时间几乎可以忽略不计，有些部分根本无法避免，考虑到投入产出比，这里只列出我们项目中有价值优化的部分 影响T1的因素 动态库加载越多，启动越慢 Objc类越多，启动越慢 C的contructor函数越多，启动越慢 C++的静态对象越多，启动越慢 Objc的+load越多，启动越慢 在整个动态链接的过程中，我们能做的事其实不多，WWDC上提到了以下几点 Load dylibs 对于这一步，苹果的建议是减少dylibs的使用，具体分为三点 合并已经存在的dylibs 减少非系统库的依赖 如果可以的话，把动态库改造为静态库 Rebase/Bind 减少Objc类数量，减少selector和category数量 减少C++虚函数数量 使用swiif stuct（减少符号数量） 随着项目的不断迭代，很多模块和方法已经被废弃但是却一直留存在项目中，导致项目越来越臃肿。在这里，我使用了CATClearProjectTool来查找项目中没有被用到的文件，在核实确认之后进行删除操作，删掉了近百个无用文件。 Objc setup 针对这一步能做的不多，暂时先不管。 Initializers 将不必须在+load方法中做的事情延迟到+initialize中 这是因为+load方法是在app启动的时候就被调用，而+initialize方法则是在Class第一次使用的时候才调用，相当于是懒加载了。可以把+load中的代码移到initialize中，并结合dispatch_once来防止重复调用。 不过我们项目中只有在使用method swizzling的时候会在+load中调用方法。所以这一点也没什么好优化的。 可以看到优化后，启动时间缩短为359.94ms, 已经达到了苹果的推荐值。 ###对于T2的优化### 影响T2的因素有以下两个 执行didFinishLauchingWithOptions的耗时 rootViewController及其childViewController的加载、view及其subviews的加载 ####优化didFinishLauchingWithOptions 对于didFinishLauchingWithOptions这部分，经过测算发现在这个函数中比较耗时的有两个操作，这里把具体函数名隐去了 在didFinishLauchingWithOptions这个方法中，主要处理的就是一些三方的初始化已经项目的基本配置。 日志、统计、监控等必须在一开始就初始化的 项目配置、推送、客服等 其他SDK和配置 设置根控制器 把一部分初始化和项目配置延迟加载 通过在首页加载完成之后发出通知，在didFinishLaunchingWithOptions里收到通知后，开辟异步线程执行以下内容 检测强制更新 初始化客服 初始化社交分享 初始化阿里百川 初始化支付服务 初始化键盘管理 获取服务城市列表 项目配置相关的多个网络请求合并为一个请求 通过上述方案，didFinishLaunchingWithOptions的执行时间缩短为1.7s左右 优化rootViewController加载我们项目中的UI总体架构如下图所示 然后在AppDelegate中进行rootViewController的设置 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; TGMainViewController *root = [[TGMainViewController alloc] init];; self.window.rootViewController = root; [self.window makeKeyAndVisible];&#125; 然后在TGMainViewController的viewDidLoad中进行它的viewControllers设置，然后再进入到具体的每个viewController的viewDidLoad方法中进行各自的初始化操作。按照常规思路来讲，整个UI初始化的过程应该是 这边的TGHomeViewController是tabBarController的viewControllers的其中一个。但实际上，这样的前提是我们不在TGMainViewController中去操作TGHomeViewController的view，如果操作了的话，调用顺序会变为 因为一般我们都把界面的初始化、网络请求、数据解析、视图渲染等操作放在 viewDidLoad 方法里，这样一来每次启动 APP 的时候，在用户看到首页之前，需要把这些事件全部都处理完，才会进入到视图渲染阶段。这大大延长了T2。 为了解决这个问题，我们把App的闪屏页作为了App的rootViewController，在展示闪屏页的同时进行首页UI的构建。 总结经过优化，App的启动时间由4.9秒缩短到2.06秒。整个流程下来后，得到的不光是app启动速度的提升，也让自己对app启动的原理有了更加深刻的理解。苹果的WWDC Session 真的是非常好的学习资料，没有谁能比得上苹果自家工程师对iOS的了解，以后要好好利用起来。 参考资料 WWDC 2016 Optimizing App Startup Time 今日头条iOS客户端启动速度优化 iOS启动时间优化]]></content>
      <categories>
        <category>项目优化</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runloop]]></title>
    <url>%2F2017%2F10%2F06%2Frunloop%2F</url>
    <content type="text"><![CDATA[Runloop学习最为一个iOS萌新，一直想弄明白RunLoop这个偏底层的知识点，之前只是大致了解过，但也没搞太明白。最近看了一些讲解RunLoop的文章和视频，在这里作点记录，加深理解。 什么是RunLoop一般来说，一个线程只能执行一个任务，执行完就会退出，如果我们需要一种机制，让线程能随时处理事件但并不退出，那么 RunLoop 就是这样的一个机制。Runloop是事件接收和分发机制的一个实现, 它并不是iOS特有的机制，在 RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。 ###RunLoopMode### runLoopMode可以说是runloop的核心内容，共有4种：source0,source1,observer,timers CFRunLoopTimer NSTimer CFRunLoopSource Source是RunLoopd的数据源抽象类（protocol） RunLoop定义了两种Source Source0: 处理App内部事件、App自己负责管理(触发)，如UIEvent、CFSocket Source1：由RunLoop和内核管理，Mach port驱动，如CFMachPort、CFMessagePort 如有需要，可从中选择一种来实现自动Source ​ UIKit通过RunLoopObserver在RunLoop两次Sleep间对·AutoReleasePool进行Pop和Push，将这次Loop中产生的Autorelease对象释放。 Runloog的应用AutoReleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011 _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西当调用dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程与GCD思考]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EGCD%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在阅读『程序员的自我修养—链接、装载与库』一书，第一章就提到了多线程的相关知识。作为计算机里一个非常重要的概念，多线程在iOS开发中也有着非常重要的地位，而线程安全也是在开发中要十分注意的地方，稍不留心就会产生意想不到的bug。这篇文章主要记录在项目中使用GCD的相关思考。 试验多线程涉及到了队列，异步/同步，串行/并行等概念，而当这些概念和GCD结合时，很容易搞不清楚会产生怎样的结果，这里就用实例来验证一下 同步并发 执行结果如下,任务在当前线程中串行执行，不会开启新线程。 异步并发 执行结果如下,开启了新线程，任务交替/同时执行的。 同步串行 执行结果如下，不会开启新线程，任务串行执行 异步串行 执行结果如下，会开启一条新线程，任务串行执行 主线程同步主队列 执行结果是互相等待造成死锁。 其他线程中调用同步主队列 通过detachNewThread方法创建线程并在创建的线程中执行syncMain方法。执行结果如下，不会开启新线程，任务串行执行。 在这种情况下不会阻塞的原因是因为syncMain被放到了其他线程中，而任务都被追加到了主队列中，任务会在主线程中执行。syncMain 任务在其他线程中执行添加任务1到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的任务1，等任务1执行完毕，再接着执行任务2、任务3。所以这里不会阻塞线程。 异步主队列 执行结果如下，没有开启新线程，任务串行执行 总结一下各种情况 并发队列 串行队列 主队列 同步 不会开启新线程，串行执行任务 不会开启新线程，串行执行任务 主线程调用：造成死锁 异步 会开启新线程，并发执行任务 会开启新线程，串行执行任务 不会开启新线程，串行执行任务。 GCD的使用场景GCD作为一种轻量级的多线程解决方案，在我们项目中的使用频率是相当高的。下面就列举一下 耗时操作 这是项目里最常见的应用场景，在网络请求或者有其他耗时操作的时候，为了避免阻塞主线程，我们把这些耗时操作放在子线程里处理，然后在主线程使用处理结果并更新UI。 123456 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //耗时操作，如网络请求 //请求完成之后，回到主线程更新UI dispatch_async(dispatch_get_main_queue(), ^&#123; //更新UI操作 &#125; 延时执行 在需要延时执行某个任务时，可以使用dispatch_after 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //延时执行任务&#125;); 执行一次任务 这也是项目中最常用到的。在创建单例、或者有整个程序运行过程中只执行一次的代码时会用到 GCD 的 dispatch_once 函数。使用dispatch_once 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。 123456- (void)once &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(默认是线程安全的) &#125;);&#125; 时序管理 某个页面存在多个请求，任务X需要在这多个请求都结束后再进行。一般情况下为了省事可能就会把B请求放在A请求的成功回调中发起，但是这样做会有几个潜在的问题： 请求过多时需要写多层嵌套 如果某个请求失败了，就不会执行下去 请求同步进行，在网络不好的情况下会造成长时间等待 这时候就可以考虑使用dispatch_group来实现 123456789101112131415161718192021dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; //请求A,在A的完成回调中调用leave dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; //请求B,在B的完成回调中调用leave dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; //请求C,在C的完成回调中调用leave dispatch_group_leave(group);&#125;);dispatch_group_notify(group, dispatch_get_main_queue, ^&#123; //网络请求完成，刷新界面&#125;); 或者使用dispatch_barrier_async，也可以实现同样的效果 定时器 由于NSTimer对Target是强引用，使用不当很容易造成内存泄漏。此外，NSTimer 的运行依赖于 Runloop，在 Runloop 的一次循环中，NSTimer 也只会执行一次，这使得在 Runloop 负担比较重时，可能会跳过NSTimer的执行，因此，在用到定时器的地方，可以用 GCD 的 TimerSource代替，YYKit中也使用了该方法 12345678910111213141516171819202122- (instancetype)initWithFireTime:(NSTimeInterval)start interval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector repeats:(BOOL)repeats &#123; self = [super init]; _repeats = repeats; _timeInterval = interval; _valid = YES; _target = aTarget; _selector = aSelector; __weak typeof (self) weakSelf = self; _lock = dispatch_semaphore_create(1); _source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue()); dispatch_source_set_timer(_source, dispatch_time(DISPATCH_TIME_NOW, (start * NSEC_PER_SEC)), (interval * NSEC_PER_SEC), 0); dispatch_source_set_event_handler(_source, ^&#123; [self fire]; &#125;); dispatch_resume(_source); return self;&#125; 线程安全 一个非常经典的多线程问题—火车站卖票。 运行的结果为 可以看到剩余的票数是乱的。这种时候就可以考虑使用semaphore来对线程进行加锁操作。 可以看到使用semaphore加锁之后，结果就是正确的。 GCD的坑GCD给我们的开发带来了非常多的便利，但如果使用不当也会造成很多问题，下面记录下GCD使用过程中容易产生问题的点。 dispatch_sync导致死锁 这个问题在上文中已经提到过。再比如下面这段代码也会造成死锁。 1234567891011- (void)test1 &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; //造成死锁 [self test2]; &#125;);&#125;- (void)test2 &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;test2&quot;); &#125;);&#125; 所以在使用dispatch_sync时一定要慎重。 dispatch_once_t必须是全局或static变量 在实现单例时正确的写法如下： 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; //实现单例代码 &#125;); 如果dispatch_once_t变量不是static或者全局的，就无法保证它只有一份实例，很可能造成不好排查的bug。 dispatch_after是延迟提交，不是延迟运行 官方文档对dispatch_after的解释如下 Enqueue a block for execution at the specified time. 它是指在指定的延时后，把一段block加入到指定队列中，而不是立刻执行。 12345678910111213- (void)dispatchAfterTest &#123; //创建串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.chendongnan.testQueue&quot;, DISPATCH_QUEUE_SERIAL); //提交一个block dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@&quot;第一个block执行完毕&quot;); &#125;); //3 秒以后提交block dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^&#123; NSLog(@&quot;第二个block执行&quot;); &#125;);&#125; 这段代码的执行后，先输出第一个block执行完毕, 再输出第二个block执行。所以在使用dispatch_after的时候要注意这点。 dispatch_barrier_async只对dispatch_queue_create(label, attr)创建的队列有效 dispatch_barrier_async对dispatch_get_global_queue得到的全局队列是无效的。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解UIView的绘制(转)]]></title>
    <url>%2F2017%2F05%2F23%2F%E7%90%86%E8%A7%A3UIView%E7%9A%84%E7%BB%98%E5%88%B6-%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[本文转自 http://vizlabxt.github.io/blog/2012/10/22/UIView-Rendering/ 理解UIView的绘制UIView是如何显示到Screen上的 也许要先从Runloop开始说，iOS的mainRunloop是一个60fps的回调，也就是说每16.7ms会绘制一次屏幕，这个时间段内要完成view的缓冲区创建，view内容的绘制（如果重写了drawRect），这些CPU的工作。然后将这个缓冲区交给GPU渲染，这个过程又包括多个view的拼接(compositing)，纹理的渲染（Texture）等，最终显示在屏幕上。因此，如果在16.7ms内完不成这些操作，比如，CPU做了太多的工作，或者view层次过于多，图片过于大，导致GPU压力太大，就会导致“卡”的现象，也就是丢帧。 苹果官方给出的最佳帧率是：60fps，也就是1帧不丢，当然这是理想中的绝佳的体验。 这个60fps改怎么理解呢？一般来说如果帧率达到25+fps，人眼就基本感觉不到停顿了，因此，如果你能让你ios程序稳定的保持在30fps已经很不错了，注意，是“稳定”在30fps，而不是，10fps，40fps，20fps这样的跳动，如果帧频不稳就会有卡的感觉。60fps真的很难达到，尤其在iphone4，4s上。 总的来说，UIView从绘制到Render的过程有如下几步： 每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store。 UIView的绘制和渲染是两个过程，当UIView被绘制时，CPU执行drawRect，通过context将数据写入backing store 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上 上面提到的从CPU到GPU的过程可用下图表示： 下面具体来讨论下这个过程 CPU bound：假设我们创建一个UILabel： UILabel* label = [[UILabel alloc]initWithFrame:CGRectMake(10, 50, 300, 14)];label.backgroundColor = [UIColor whiteColor];label.font = [UIFont systemFontOfSize:14.0f];label.text = @&quot;test&quot;;[self.view addSubview:label]; 这个时候不会发生任何操作，由于UILabel重写了drawRect，因此，这个view会被marked as “dirty”： 类似这个样子： 然后一个新的Runloop到来，上面说道在这个Runloop中需要将界面渲染上去，对于UIKit的渲染，Apple用的是它的Core Animation。 做法是在Runloop开始的时候调用： [CATransaction begin] 在Runloop结束的时候调用 [CATransaction commit] 在begin和commit之间做的事情是将view增加到view hierarchy中，这个时候也不会发生任何绘制的操作。 当[CATransaction commit]执行完后，CPU开始绘制这个view： 首先CPU会为layer分配一块内存用来绘制bitmap，叫做backing store 创建指向这块bitmap缓冲区的指针，叫做CGContextRef 通过Core Graphic的api，也叫Quartz2D，绘制bitmap 将layer的content指向生成的bitmap 清空dirty flag标记 这样CPU的绘制基本上就完成了。 通过time profiler 可以完整的看到个过程： Running Time Self Symbol Name2.0ms 1.2% 0.0 +[CATransaction flush]2.0ms 1.2% 0.0 CA::Transaction::commit()2.0ms 1.2% 0.0 CA::Context::commit_transaction(CA::Transaction*)1.0ms 0.6% 0.0 CA::Layer::layout_and_display_if_needed(CA::Transaction*)1.0ms 0.6% 0.0 CA::Layer::display_if_needed(CA::Transaction*)1.0ms 0.6% 0.0 -[CALayer display]1.0ms 0.6% 0.0 CA::Layer::display()1.0ms 0.6% 0.0 -[CALayer _display]1.0ms 0.6% 0.0 CA::Layer::display_()1.0ms 0.6% 0.0 CABackingStoreUpdate_1.0ms 0.6% 0.0 backing_callback(CGContext*, void*)1.0ms 0.6% 0.0 -[CALayer drawInContext:]1.0ms 0.6% 0.0 -[UIView(CALayerDelegate) drawLayer:inContext:]1.0ms 0.6% 0.0 -[UILabel drawRect:]1.0ms 0.6% 0.0 -[UILabel drawTextInRect:] 假如某个时刻修改了label的text： label.text = @&quot;hello world&quot;; 由于内容变了，layer的content的bitmap的尺寸也要变化，因此这个时候当新的Runloop到来时，CPU要为layer重新创建一个backing store，重新绘制bitmap。 CPU这一块最耗时的地方往往在Core Graphic的绘制上，关于Core Graphic的性能优化是另一个话题了，又会牵扯到很多东西，就不在这里讨论了。 GPU bound：CPU完成了它的任务：将view变成了bitmap，然后就是GPU的工作了，GPU处理的单位是Texture。 基本上我们控制GPU都是通过OpenGL来完成的，但是从bitmap到Texture之间需要一座桥梁，Core Animation正好充当了这个角色： Core Animation对OpenGL的api有一层封装，当我们的要渲染的layer已经有了bitmap content的时候，这个content一般来说是一个CGImageRef，CoreAnimation会创建一个OpenGL的Texture并将CGImageRef（bitmap）和这个Texture绑定，通过TextureID来标识。 这个对应关系建立起来之后，剩下的任务就是GPU如何将Texture渲染到屏幕上了。 GPU大致的工作模式如下： 整个过程也就是一件事：CPU将准备好的bitmap放到RAM里，GPU去搬这快内存到VRAM中处理。 而这个过程GPU所能承受的极限大概在16.7ms完成一帧的处理，所以最开始提到的60fps其实就是GPU能处理的最高频率。 因此，GPU的挑战有两个： 将数据从RAM搬到VRAM中 将Texture渲染到屏幕上 这两个中瓶颈基本在第二点上。渲染Texture基本要处理这么几个问题： Compositing：Compositing是指将多个纹理拼到一起的过程，对应UIKit，是指处理多个view合到一起的情况，如 [self.view addsubview : subview]。 如果view之间没有叠加，那么GPU只需要做普通渲染即可。 如果多个view之间有叠加部分，GPU需要做blending。 加入两个view大小相同，一个叠加在另一个上面，那么计算公式如下： R = S+D*(1-Sa) R: 为最终的像素值 S: 代表 上面的Texture（Top Texture） D: 代表下面的Texture(lower Texture) 其中S,D都已经pre-multiplied各自的alpha值。 Sa代表Texture的alpha值。 假如Top Texture（上层view）的alpha值为1，即不透明。那么它会遮住下层的Texture。即,R = S。是合理的。 假如Top Texture（上层view）的alpha值为0.5，S 为 (1,0,0)，乘以alpha后为(0.5,0,0）。D为(0，0，1)。 得到的R为（0.5，0，0.5）。 基本上每个像素点都需要这么计算一次。 因此，view的层级很复杂，或者view都是半透明的（alpha值不为1）都会带来GPU额外的计算工作。 Size这个问题，主要是处理image带来的，假如内存里有一张400x400的图片，要放到100x100的imageview里，如果不做任何处理，直接丢进去，问题就大了，这意味着，GPU需要对大图进行缩放到小的区域显示，需要做像素点的sampling，这种smapling的代价很高，又需要兼顾pixel alignment。计算量会飙升。 Offscreen Rendering And Mask如果我们对layer做这样的操作： label.layer.cornerRadius = 5.0f;label.layer.masksToBounds = YES; 会产生offscreen rendering,它带来的最大的问题是，当渲染这样的layer的时候，需要额外开辟内存，绘制好radius，mask，然后再将绘制好的bitmap重新赋值给layer。 因此继续性能的考虑，Quartz提供了优化的api： label.layer.cornerRadius = 5.0f;label.layer.masksToBounds = YES;label.layer.shouldRasterize = YES;label.layer.rasterizationScale = label.layer.contentsScale; 简单的说，这是一种cache机制。 同样GPU的性能也可以通过instrument去衡量： 红色代表GPU需要做额外的工作来渲染View，绿色代表GPU无需做额外的工作来处理bitmap。 That’s all]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook/chisel]]></title>
    <url>%2F2017%2F04%2F19%2Ffacebook-chisel%2F</url>
    <content type="text"><![CDATA[前几天看了一篇关于LLDB的文章Dancing in the Debugger，才发现它的功能如此强大。之前只会使用po这样简单的功能，实在是浪费了LLDB在调试中所能发挥的巨大作用。Facebook有一个开源项目chisel，Github地址：chisel，对LLDB命令进一步封装，提供了一些非常方便的调试功能。 安装按照官网提示 12brew updatebrew install 安装完成后提示 ==&gt; Caveats Add the following line to ~/.lldbinit to load chisel when Xcode launches: command script import /usr/local/Cellar/chisel/1.5.0/libexec/fblldb.py 意思是需要将command script import /usr/local/Cellar/chisel/1.5.0/libexec/fblldb.py 这段代码加到./lldbinit中，这样每次LLDB启动时都会执行这段python脚本。 常用命令pviews 可以打印view的层级 pvc 打印viewcontrroller的层级 show&amp;hide 显示和隐藏一个指定的UIView fv&amp;fvc 通过类名搜索内存中存在的view和viewcontroller实例 mask/unmask 给view或者layer覆盖/移除mask border/unborder 给view或者layer添加/去掉border caflush 重新绘制界面，比如在控制台修改view的backgroundColor，调用caflush就可以直接看到背景色的改变 bmessage 提供打断点功能。一般我们打断点都会选择在行标上打，但比如我们想在[OneViewController viewWillAppear:]里打断点，但它并没有实现viewWillAppear:这个方法, 这时我们就可以通过 (lldb) bmessage -[OneViewController viewWillAppear:] ,这个命令会在其父类的viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[OneViewController class]] 以上就是chisel的一些常用命令，当然你也可以自定义python脚本去实现你想要的功能。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage Cache Mechanism]]></title>
    <url>%2F2017%2F04%2F19%2FSDWebImage-Cache-Mechanism%2F</url>
    <content type="text"><![CDATA[SDWebImage是很多项目中都会用到的三方库。这篇文章用来记录下学习SDWebImage图片缓存机制的心得。 SDWebImageCacheConfig，正如其名，主要缓存策略的配置选项，比如最大缓存容量、缓存过期时间，读取缓存选项等，比较简单。 SDWebImageCache 1234567891011121314typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; /** * The image wasn&apos;t available the SDWebImage caches, but was downloaded from the web. */ SDImageCacheTypeNone, /** * The image was obtained from the disk cache. */ SDImageCacheTypeDisk, /** * The image was obtained from the memory cache. */ SDImageCacheTypeMemory&#125;; 在SDWebImageCache头文件里，可以看到有三种缓存策略,SDImageCacheTypeNone，SDImageCacheTypeDisk，SDImageCacheTypeMemory 分别是不使用缓存，硬盘缓存和内存缓存。 当我们使用SDImage加载图片是，往往会用到SDWebImage的扩展 [imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;https://pic.tugou.com/material/1476243549_0622559.jpg&quot;]];, 这个方法会调用SDWebImageManager的downloadImageWithURL 123id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; &#125;]; SDWebImageManager 内部的 downloadImageWithURL方法会先使用我们前面提到的 SDImageCache 类的 queryDiskCacheForKey 方法，查询图片缓存： 123operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123; ...&#125;]; queryDiskCacheForKey 方法会先查询是否存在Memory cahce 123- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123; return [self.memCache objectForKey:key];&#125; 12345678910111213141516- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123; // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; return image; &#125; // Second check the disk cache... UIImage *diskImage = [self diskImageForKey:key]; if (diskImage) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; return diskImage;&#125; LRU算法]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS签名原理学习记录]]></title>
    <url>%2F2017%2F03%2F11%2FiOS-signature-and-certificate%2F</url>
    <content type="text"><![CDATA[iOS签名机制一直是很困扰我的一件事，真机测试或者打包的时候，经常会遇到各种情况的报错，CertificateRequest,p12,Provision Profile,Code Sign五花八门的，所以在这里系统地记录一下相关知识，不再一知半解地去处理这些问题。 对称加密对称加密就是指加密和解密使用同一个密钥的加密方式。 举个简单的例子 密钥 ：X 加密算法 ：每个数字 + X 明文 ： 12345 密钥X为1，那么加密结果就是23456； 对称加密使得对密钥的保管显得尤为重要，如果传输过程中密钥泄漏，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。 非对称加密非对称加密有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。 非对称加密算法中最常见的应该就是RSA了,简单介绍下RSA 选两个质数 p 和 q，相乘得出一个大整数n，例如 p = 19，q = 7，n = pq = 133 选 1-n 间的随便一个质数e，例如 e = 11 经过一系列数学公式，算出一个数字 d，满足：a.通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。b.如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。 上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用私钥加密，公钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥 (只知道 n 和 e)的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而 n 数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。 苹果为了确保安装到用户手机上的App都是被官方认证过的，苹果推出了签名机制，那么这个签名又是什么呢？ 数字签名对于某份账单或者文件之类的东西，如果它得到了我的确认，我就会用签名来表示我同意了。那么数字签名也一样，它的作用是我对某一份数据打个标记（就像签名一样），表示我认可了这份数据，然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。 有了上述的非对称加密算法，就可以实现这个需求： 首先用一种算法(这里用md5举例)，算出原始数据的摘要。 生成一份非对称加密的公钥和私钥，私钥自己保管，公钥公布出去。 对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。 用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。 之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位 / 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。 了解了什么是数字签名，就可以更好地理解苹果是如何通过数字签名机制来确保安装到iPhone的App都是经过苹果认证的。 方案一 如上图所示，最简单的方案，就是由苹果生成一堆公私钥，在iOS设备里内置一个公钥，在苹果后台保存一份私钥，但App上传到AppStore时，苹果用私钥对App进行数字签名。iOS设备下载App后，用公钥进行解密验证，若相等，则说明App是由苹果官方认证的。 这个方案非常简洁明了，但是有一个缺点，因为除了AppStore外，我们还有其他方法可以安装App 安装开发版本App对于开发者来说，如果每次调试app还需要把安装包传到Apple后台签名，那肯定是不能忍的。但是苹果也想要对这部分App有控制权，不能被滥用导致非开发app也能被安装。因此就有了如下的解决方案 在mac上生成一对公私钥，图里标示为公钥L，私钥L，L代表Local的意思 苹果自己也生成一对公私钥，私钥在苹果后台，公钥在每个iOS设备上，标示为公钥L，私钥A， A代表Apple 把公钥L传给苹果后台，用私钥A对公钥L进行签名，得到一份包含了公钥L以及其签名的数据，称为证书。 在开发中，编译完一个App后，通过本地的私钥L对App进行签名，同时把第三部得到的证书一起打包进App 在安装时，通过iOS系统内置的公钥A，去解密第三步用私钥A加密的数据，来验证证书的数字签名是否正确 验证证书后，确保了公钥L是苹果认证的，再用公钥L去验证App的签名,这里就间接验证了这个app的安装行为是经过苹果允许的（这里只验证安装行为，不验证App是否被改动，因为在开发阶段App是不断变化的） 上述流程解决了开发版本App需要经过苹果认证，但是还没有解决可能存在的滥用问题，于是苹果又加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某个具体App。 在上述第三步用私钥A签名公钥L之外，也可以加上其他数据，这些数据都可以保证是经过苹果官方认证的，不会被篡改。 把AppID和允许安装的设备ID列表等数据，在第三步的时候和公钥L一起组成证书，用私钥A进行签名，在第五步 r如果通过验证,就可以确定拿到的设备ID列表/AppID/公钥L是经过苹果认证的，这样就避免了滥用。 最终流程除了上述情况外，苹果还想要控制App里的iCloud/Push等等，苹果把这些权限开关统一称为Entitlements，它也需要通过签名授权。 把各种信息塞入到证书是不符合规范的，因此，苹果又搞了个叫做Provision Profile的东西，它就包括了证书以及上述提到的所有额外信息以及信息的签名。 所以整个流程又变为 再来看一下整个流程 在mac上生成一对公私钥，图里标示为公钥L，私钥L，L代表Local的意思 苹果自己也生成一对公私钥，私钥在苹果后台，公钥在每个iOS设备上，标示为公钥L，私钥A， A代表Apple 把公钥L传给苹果后台，用私钥A对公钥L进行签名，得到一份包含了公钥L以及其签名的数据，称为证书。 在苹果后台申请AppID，配置好设备ID和App的各项权限，再加上第三部生成的证书，组成的数据用私钥A签名后，把数据和签名一起组成一个Provision Profile文件，下载到本地。 在开发时，编译完一个App后，用私钥L对App进行签名，同时把第四步得到的Probvision Profile文件打包进App里，文件名为embeded.mobileprovision，把App安装到手机上。 在安装时，iOS系统去的证书，通过私钥A去验证embedded.mobileprovision的数字签是否正确，证书签名也会验证一遍 确保embedded.mobileprovision里的数据都是苹果授权的之后，就可以取出数据，来验证数据是否符合要求如设备ID是否在设备列表上，AppID是否对应，权限开关是否对应等。 相关操作上面的步骤对应我们的具体操作和概念如下： 第1步对应的是在Mac上的keychain中，从证书颁发机构请求证书。这里就生成了公钥L和私钥L，保存的CertificateSigningRequest就是公钥，私钥则保存在本地电脑中。 第2步是由苹果处理 第3步对应把CertificateSigningRequest传到苹果后台生成证书，并下载到本地。这是本地有两个证书，一个是第一步生成的，一个是这边下载的。keychain会这两个证书关联起来，因为他们的公私钥是对应的。在Xcode选择证书时，实际上会找到keychain里对应的私钥去签名。这里私钥只有生成它的Mac本地有，如果别的Mac也想要编译签名这个App，就需要把私钥导出给其他Mac使用。在keychain里导出私钥会生成一个.p12文件，其他Mac打开这个文件后就导入了这个私钥。 这一步是在苹果开发者官网操作的，配置AppID/权限/设备等，最后下载Provision Profile文件。 第 5 步 Xcode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。 第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。 相关概念 证书：包含公钥或者私钥，由其他机构对其签名组成的数据包 Entitlements：包含了App权限开关信息 CertificateSigningRequest :本地公钥 p12 : 本地私钥，可以导入到其他电脑 Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。 其他以上的流程是以开发包为例子的，In-house和ad-hoc流程也是大同小异的。 而 AppStore 的签名验证方式有些不一样，前面提到的最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。 据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。 那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。 所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime之methodSwizzling]]></title>
    <url>%2F2017%2F02%2F23%2Fruntime%E4%B9%8BmethodSwizzling%2F</url>
    <content type="text"><![CDATA[关于runtime学习的第三篇文章，记录下methodSwizzling的相关知识。 Method swizzling，字面翻译就是方法交换，它可以允许我们动态地替换方法的实现。它被称为runtime的黑魔法，之所以被称为黑魔法，一方面有其强大之处，另一方面用的不好也会产生意想不到的问题，所以在使用method swizzling的时候一定要慎重考虑。 首先要分清几个概念: Selectors,Methods,Implementations Selector（typedef struct objc_selector *SEL）:在运行时 Selector 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 Implementation（typedef id (*IMP)(id, SEL,...)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象metaclass）。第二个参数是这个方法的名字selector，该方法的真正参数紧随其后。 理解 selector, method, implementation 这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来处理消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个 IMP，同时重命名了原方法的IMP为一个新的 selector。 Method swizzling常用的APIBOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 为一个类添加一个带有指定SEL名和实现的新方法； class_addMethod会添加一个覆盖父类的实现，但不会取代原有类的实现。也就是说如果class_addMethod返回YES，说明子类中没有originalSelector，通过class_addMethod为其添加了originalSelector，并使其实现（IMP）为我们想要替换的实现。反之如果class_addMethod返回NO，说明子类中本身就具有originalSelector的实现，直接调用交换即可。 Method class_getInstanceMethod(Class cls, SEL name); 通过SEL名获取指定类的实例方法 Method class_getClassMethod(Class cls, SEL name); 通过SEL名获取指定类的类方法 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types); 通过SEL名替换指定类的方法实现 IMP class_getMethodImplementation(Class cls, SEL name); 通过SEL名获取指定类的方法实现 method_exchangeImplementations(Method m1, Method m2); 交换两个方法的实现 上述API就是实现method swizzling的常用API，可以把它们进一步封装为类方法方便日后调用。这里我们通过给NSObject添加分类来实现。 为什么要添加didAddMethod判断 先尝试添加原SEL其实是为了做一层保护，因为如果这个类没有实现originalSelector，但其父类实现了，那class_getInstanceMethod会返回父类的方法。这样method_exchangeImplementations替换的是父类的那个方法，这当然不是我们想要的。所以先尝试添加 orginalSelector，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现进行交换。 实用场景使用method swizzling和category来添加埋点 对于页面展示的统计，需要每次在类的viewWillAppear和viewWillDisappear方法中添加埋点代码，非常冗余且容易出错。可以通过method swizzling来一劳永逸得解决。 首先给UIViewController添加一个category，然后去重写+(void)load方法，因为该方法在类被加载到内存时会且仅会被调用一次。 12345678910111213141516171819202122232425262728293031#import &lt;objc/runtime.h&gt;#import &quot;&quot;NSObject+Swizzling.h&quot;&quot;@implementation UIViewController (swizzling)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //这里用到了上面所提到的封装好的方法 [self methodSwizzlingWithOriginalSelector:@selector(viewWillAppear:) bySwizzledSelector:@selector(swizzlingViewWillAppear:)]; [self methodSwizzlingWithOriginalSelector:@selector(viewWillDisappear:) bySwizzledSelector:@selector(swizzlingViewWillDisappear:)]; &#125;);&#125;// 我们自己实现的方法，也就是和self的viewWillAppear/viewWillDisappear方法进行交换的方法。- (void)swizzlingViewWillAppear &#123; [self swizzlingViewWillAppear:animated]; NSString *statisticTitle = self.statisticTitle ? self.statisticTitle : NSStringFromClass([self class]); NSLog(@&quot;页面进入%@&quot;, statisticTitle);&#125;- (void)swizzlingViewWillDisappear &#123; [self swizzlingViewWillDisappear:animated]; NSString *statisticTitle = self.statisticTitle ? self.statisticTitle : NSStringFromClass([self class]); NSLog(@&quot;页面退出%@&quot;,statisticTitle);&#125;@end 通过上述操作，当一个继承自UIViewController类的类被加载的时候，就会把viewWillAppear和viewWillDisappear方法替换为我们自己实现的swizzlingViewWillAppear和swizzlingViewWillDisappear方法，从而实现页面展示的自动统计。 防崩溃 在OC中，为一个字典插入nil对象，会导致crash；对一个数组进行增删改查也很容易发生数组越界的情况，可以通过method swizzling来处理这些崩溃的情况，下面以NSDictionary为例，实现字典插入对象的防崩溃。 12345678910111213141516171819202122232425262728293031323334@implementation NSDictionary (Safe)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self methodSwizzlingWithOriginalSelector:@selector(dictionaryWithObjects:forKeys:count:) bySwizzledSelector:@selector(safe_dictionaryWithObjects:forKeys:count:)]; &#125;);&#125;+ (instancetype)safe_dictionaryWithObjects:(const id _Nonnull __unsafe_unretained *)objects forKeys:(const id &lt;NSCopying&gt; _Nonnull __unsafe_unretained *)keys count:(NSUInteger)cnt &#123; id instance = nil; @try &#123; instance = [self safe_dictionaryWithObjects:objects forKeys:keys count:cnt]; &#125; @catch (NSException *exception) &#123; //处理错误的数据，然后重新初始化一个字典 NSUInteger index = 0; id _Nonnull __unsafe_unretained newObjects[cnt]; id _Nonnull __unsafe_unretained newkeys[cnt]; for (int i = 0; i &lt; cnt; i++) &#123; if (objects[i] &amp;&amp; keys[i]) &#123; newObjects[index] = objects[i]; newkeys[index] = keys[i]; index++; &#125; &#125; instance = [self safe_dictionaryWithObjects:newObjects forKeys:newkeys count:index]; &#125; @finally &#123; return instance; &#125;&#125;@end 1234567891011121314151617181920212223242526272829303132333435363738@implementation NSMutableDictionary (Safe)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class dictCls = NSClassFromString(@&quot;__NSDictionaryM&quot;); [dictCls methodSwizzlingWithOriginalSelector:@selector(setObject:forKey:) bySwizzledSelector:@selector(safe_setObject:forKey:)]; [dictCls methodSwizzlingWithOriginalSelector:@selector(removeObjectForKey:) bySwizzledSelector:@selector(safe_removeObjectForKey:)]; &#125;);&#125; #pragma mark - setObject:forKey:- (void)safe_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey &#123; @try &#123; [self safe_setObject:anObject forKey:aKey]; &#125; @catch (NSException *exception) &#123; //这里可以添加一些上报出错堆栈信息的代码 &#125; @finally &#123; &#125;&#125;#pragma mark - removeObjectForKey:- (void)safe_removeObjectForKey:(id)aKey &#123; @try &#123; [self safe_removeObjectForKey:aKey]; &#125; @catch (NSException *exception) &#123; //这里可以添加一些上报出错堆栈信息的代码 &#125; @finally &#123; &#125;&#125;@end 这里没有用self来调用交换方法，是因为对于NSArray/NSDictionary等属于类簇的类，它们的子类如NSMutableArray/NSMutableDictionary的真实类不能通过[self class]获取，而method swizzling只对真实类起作用。 真实类 NSMutableArray __NSArrayM NSDictionary __NSDictionaryM 同样的，对数组、NSString、NSMutableString等类也可以采取类似的方法来防崩溃。 注意事项可以看到，method swizzling的功能十分强大，但是也容易发生意想不到的问题，使用时需要注意 只在 +load中执行method swizzling。 在Objective-C runtime会自动调用两个类方法，分别为+load与+ initialize。+load 方法是在类被加载的时候调用的，也就是一定会被调用。而+initialize方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说+initialize方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的+initialize方法是永远不会被调用的。此外+load方法还有一个非常重要的特性，那就是子类、父类和分类中的+load方法的实现是被区别对待的。换句话说在 Objective-C runtime自动调用+load方法时，分类中的+load方法并不会对主类中的+load方法造成覆盖。综上所述，+load 方法是实现 Method Swizzling 逻辑的最佳“场所”。 此外，方法交换应该要线程安全，而且保证在任何情况下（多线程环境，或者被其他人手动再次调用+load方法）只交换一次，防止再次调用又将方法交换回来。除非只是临时交换使用，在使用完成后又交换回来。 最常用的解决方案是在+load方法中使用dispatch_once来保证交换是安全的。 当用Method Swizzling替换子类中未重写的父类方法实现时，class_getInstanceMethod会获取到子类没有重写的父类方法的Method，这个Method对应的是父类中的方法，用这个Method调用method_exchangeImplementations实现Method Swizzling之后就会交换父类Method和子类Method的实现。然后在基类对象上调用被交换的方法时，如果该方法调用了自身就会引起unrecognized selector异常。 被swizzled的方法如果依赖于cmd，hook之后cmd发生了变化，就会有问题（一般你hook的是系统类，也不知道系统有没有用cmd这个参数）。 我们知道OC Method中会有两个隐含的参数 sel,cmd，有时使用关联属性的场合可能会懒得声明(void *)的key，直接使用cmd变量objc_setAssociatedObject(self, _cmd, xx, 0);这会导致当前IMP对cmd的依赖。 而一旦该方法被Swizzling，那么方法的cmd肯定发生了变化，这种bug简直无法被定位。 所以在使用method swizzling的时候，一定要多加注意，避免产生意想不到的bug。]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程与王者荣耀]]></title>
    <url>%2F2017%2F02%2F16%2F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%2F</url>
    <content type="text"><![CDATA[最近被同事带着玩了王者荣耀。 玩的过程中突然想到一点。 一个英雄，你看再多的介绍、攻略、视频，都不如上手实战几把熟悉得快。 编程也是，看再多的技术文章都不如实际上手敲几行代码来的有用。当然理论学习还是很必要的，不过在学习之前，先实战，遇到坑，再去深入学习，我觉得这样可能效果会更佳。]]></content>
      <tags>
        <tag>瞎话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI Test]]></title>
    <url>%2F2017%2F02%2F05%2FUI-Test%2F</url>
    <content type="text"><![CDATA[UI Tests是什么？UI Tests是一个自动测试UI与交互的Testing组件 UI Tests有什么用？它可以通过编写代码、或者是记录开发者的操作过程并代码化，来实现自动点击某个按钮、视图，或者自动输入文字等功能。 UI Tests的重要性在实际的开发过程中，随着项目越做越大，功能越来越多，仅仅靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UI Tests就可以帮助解决这个问题了 使用方法第一步：添加UI Tests如果是新项目，则创建工程的时候可以直接勾选选项，如下图 如果是已有项目，可以通过添加target的方法添加一个UI Test 第二步：创建测试代码手动创建测试代码打开测试文件，在testExample()方法中添加测试代码 如果不知道如何写测试代码，则可以参考自动生成的代码样式 自动生成测试步骤 选择测试文件后，点击录制按钮 这时候开始进行操作，它会记录你的操作步骤，并生成测试代码下图就是在一些操作后自动生成的测试代码 时候可以分析测试代码的语法，以便你自己手动修改或者手写测试代码 开始测试点击testExample方法旁边的播放按钮，它就开始进行自动测试了，这时候你会看到app在自动操作 下面介绍一下测试元素的语法XCUIApplication：继承XCUIElement，这个类掌管应用程序的生命周期，里面包含两个主要方法launch():启动程序terminate():终止程序 XCUIElement: 继承NSObject，实现协议XCUIElementAttributes, XCUIElementTypeQueryProvider可以表示系统的各种UI元素exist:可以让你判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试descendantsMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:取某种类型的元素以及它的子类集合childrenMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:取某种类型的元素集合，不包含它的子类 这两个方法的区别在于，你仅使用系统的UIButton时，用childrenMatchingType就可以了，如果你还希望查询自己定义的子Button，就要用descendantsMatchingType 另外UI元素还有一些交互方法tap():点击doubleTap():双击pressForDuration(duration: NSTimeInterval):长按一段时间，在你需要进行延时操作时，这个就派上用场了swipeUp():这个响应不了pan手势，暂时没发现能用在什么地方，也可能是beta版的bug，先不解释typeText(text: String):用于textField和textView输入文本时使用，使用前要确保文本框获得输入焦点，可以使用tap()函数使其获得焦点]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime之消息转发]]></title>
    <url>%2F2016%2F11%2F17%2Fruntime%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[runtime的第二篇文章，记录下消息转发相关知识 在项目开发中，一个很常见的报错是 Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person run]: unrecognized selector sent to instance，意思就是向实例发送了不能识别的方法。想要了解其发生根源以及解决方案，就需要深入了解runtime的消息转发机制。 在初学OC的时候，只知道方法调用是[Object Method](实例方法)或者[Class Method]（类方法）的形式（其实类也是一种对象-类对象，在后文会提到）。在OC中，方法调用也被称为消息发送，这是因为 [Object Method]在运行时会被编译器转换成objc_msgSend(receiver, selector),如果方法含有参数，则是objc_msgSend(receiver, selector, arg1, arg2, …)的形式。 1234567891011121314// Person 类@interface MyClass: NSObject- (void)run;@end@implementation Person- (void)run &#123; NSLog(@&quot;person run&quot;);&#125;@endPerson *person = [[Person alloc] init];[person run];// 输出： person run 以上述代码为例，[person run]可以写成((void (*)(id, SEL))(void *) objc_msgSend)(person, @selector(run)); id objc_msgSend(id self, SEL op, …);就是msgSend方法了，其中self指消息的接受者，op 指消息的方法名，...指参数列表 到这里就已经大致了解了OC方法调用的底层表现，接下来需要进一步探究runtime如何实现msgSend。 方法寻找过程Objective-C是一门面向对象的语言，我们平时接触最多的也就是类和对象，而对象又被分为实例对象，类对象、元类对象以及根元类对象，他们通过isa指针互相关联起来，下面是一张它们的关系图。 上图各种对象的关系总结如下 实例对象通过isa指针，找到类对象Class; 类对象通过isa指针，找到元类对象；元类对象通过isa指针，找到根元类对象；根元类的isa指针指向自己。 类对象通过super_class指针找到它的父类对象，父类对象通过super_class指针找到根类对象，根类对象的父类是nil；元类对象通过super class指针找到父元类，父元类对象通过super class指针找到根元类对象，根元类对象的supe class指针指向根类对象。 在NSObject.h中，我们可以看到NSObject的类定义如下 可以看到，NSObject拥有一个Class类型的变量isa 在objc4-680源码的objc-private.h中，可以看到如下定义 可以看出，OC的Class其实就是 struct objc_class, 而OC的对象实际上就是struct objc_object 123456&gt;typedef struct objc_object *id;&gt;&gt;struct objc_object &#123;&gt; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&gt;&#125;;&gt; 1234567891011121314struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 可以看到obje_class中也有一个isa指针，说明类本身也是一个对象。 这里我们不详细展开每个属性的含义是什么，只关注和方法相关的属性，可以看到在objc_class的结构体中，有一个objc_method_list 结构体，在objc_method_list中有一个objc_mehtod结构体。 12345678910struct objc_method_list &#123; struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; Method 12345struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; //方法名称 char * _Nullable method_types OBJC2_UNAVAILABLE; //参数和返回类型的描述 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法具体实现的指针&#125; Mehtod代表类中某个方法的类型，它存储了方法名、参数和返回类型以及方法实现的指针 这里的method_types可以参考苹果runtime的文档 SEL &amp; IMP IMP是一个函数指针，由编译器生成，当发出一个OC消息时，最终执行的代码就是由这个函数指针来指定的，而IMP这个函数指针就指向了这个方法的实现。 IMP指向的方法与objc_methodSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的选择子，通过一组id和SEL参数就能确定唯一的方法实现地址。 Cache 123456789struct objc_cache &#123; unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buckets[1] OBJC2_UNAVAILABLE;&#125;; Cache为方法调用的性能进行优化，每当对象接收到一个消息时，它不会在isa指针指向的类的方法列表中遍历查找能够响应的方法，而是优先在Cache中查找。Runtime会把被调用过的方法存到Cache中。 方法是通过isa指针，查找到Class的methodLists。如果子类没能实现对应的方法实现，会追溯到其父类查找。 到这里，我们就能明白对象调用方法的基本逻辑了,以上文的Person run为例 方法调用先被编译成(void (*)(id, SEL))(void *) objc_msgSend)(person, @selector(run)) 根据person的isa指针, 找到person的类对象Person 在Person的方法缓存中查找，如果找到了就返回该IMP 如果没有找到，就到它的方法列表中查找，如果找到了，则将IMP返回，并将它加入cache中缓存起来。 如果在该类的方法列表中也没有找到，那就通过super_class指针去其父类的方法列表中查找，直到在某个父类方法列表中找到对应的IMP并返回，并加入chche中。 如果在自身以及父类的方法列表中都没哟刟对应的IMP，则进入下面要讲到的消息转发流程。 如果是调用类方法，那么一开始会通过类对象的isa指针找到元类对象，类方法就保存在元类对象中，之后的步骤也和调用实例对象方法一样。 消息转发那么回到文章开头的问题，unrecognized selector sent to instance报错，用消息转发来解释的话就是消息接收者找不到对应的selector 当在methodList中找不到对应的selector后，就会走消息转发流程，系统会给我们三次补救的机会。 第一次 123&gt; + (BOOL)resolveInstanceMethod:(SEL)sel &#123;&#125; &gt; + (BOOL)resolveClassMethod:(SEL)sel &#123;&#125; &gt; 上述一个对应实例方法，一个对应类方法 官方文档已经讲的很清楚了，可以在该方法内，通过class_addMethod动态地添加selector的实现。 第二次 如果上述方法返回值为NO，那么会执行 (id)forwardingTargetForSelector:(SEL)aSelector {} 如果这个方法返回一个非空并且非自己本身的对象，那么会把这个对象作为新的消息接收者，由该对象去处理消息。 第三次 如果上述方法返回nil，那么就会执行到最后一步，也是代价最大的一步。 (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {} (void)forwardInvocation:(NSInvocation *)anInvocation {} 第一个方法要求返回一个方法签名，第二个方法转发具体的方法实现，两者相互依赖，只有返回了正确的方法签名才会执行第二个方法。 用一张图来总结一下整个消息转发流程 实例验证1234567#import &lt;Foundation/Foundation.h&gt;@interface RuntimeObject : NSObject- (void)test;@end 在RuntimeObject类的.h文件中，声明一个test方法，但是在.m文件中不实现 然后在Appdelegate的didFinishLaunchingWithOptions中调用test方法 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. RuntimeObject *obj = [[RuntimeObject alloc] init]; [obj test]; return YES;&#125; 毫无疑问，这样的结果就是会造成程序崩溃，崩溃原因就是 Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[RuntimeObject test]: unrecognized selector sent to instance 0x600002254240&#39;** 现在我们按照消息转发的流程来处理这个未被实现的实现的selector。 这里添加了一个testImp来作为test的实现，运行之后打印 可以看到resolveInstanceMethod成功得为test方法提供了实现,使得程序不再崩溃。 然后再看(id)forwardingTargetForSelector:(SEL)aSelector {}方法，为了验证该方法，要把resolveInstanceMethod的返回值改为NO，然后新建一个Account类, 在该类的.m文件中实现test方法。 然后修改RuntimeObject.m的代码 运行之后，打印结果为 可以看到消息被成功转发给了Account，并且执行了。 最后，验证下消息转发的第三部 在forwadingTargetForSelector中返回nil, 在methodSignatureForSelector中返回对应的方法签名，最终在forwardInvocation中完成消息转发。 打印结果也验证了转发消息成功。 以上就是Runtime消息转发机制的相关学习总结。]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime之AssosiatedObject]]></title>
    <url>%2F2016%2F10%2F05%2Fruntime%E4%B9%8BassociatedObject%2F</url>
    <content type="text"><![CDATA[不得不说OC的runtime特性真的是十分强大，于是想着要系统得记录一下runtime的相关知识点和思考。由于涉及到的内容很多，所以把它们整理成了几个部分。第一篇就写点关于关联对象（AssociatedObject）相关内容。 在object/runtime.h文件中，找到相关API 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Sets an associated value for a given object using a given key and association policy. * * @param object The source object for the association. * @param key The key for the association. * @param value The value to associate with the key key for object. Pass nil to clear an existing association. * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.” * * @see objc_setAssociatedObject * @see objc_removeAssociatedObjects */OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);/** * Returns the value associated with a given object for a given key. * * @param object The source object for the association. * @param key The key for the association. * * @return The value associated with the key \e key for \e object. * * @see objc_setAssociatedObject */OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);/** * Removes all associations for a given object. * * @param object An object that maintains associated objects. * * @note The main purpose of this function is to make it easy to return an object * to a &quot;pristine state”. You should not use this function for general removal of * associations from objects, since it also removes associations that other clients * may have added to the object. Typically you should use \c objc_setAssociatedObject * with a nil value to clear an association. * * @see objc_setAssociatedObject * @see objc_getAssociatedObject */OBJC_EXPORT void objc_removeAssociatedObjects(id object) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0); 以及枚举类型的引用策略： 123456789101112131415/** * Policies related to associative references. * These are options to objc_setAssociatedObject() */typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; API解析void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) API可以为两个对象建立起关联 id object ：关联者 id value : 被关联者 const void *key : 被关联者的key，可以通过该key获取该关联者 objc_AssociationPolicy policy ：表示被关联者的引用策略，也就是内存管理，通过上面的枚举来设置。 id objc_getAssociatedObject(id object, const void *key) API可以通过事先设置的Key获取被关联对象 id object ：关联者 const void *key : 被关联者的key void objc_removeAssociatedObjects(id object) 该 API 可以移除一个 关联者 对象所有的 被关联者。当需要移除特定的对象时，我们可以使用objc_setAssociatedObject方法并指定 id value 参数对象为空即可。 为category添加属性当我们使用@property声明属性时，编译器会自动帮我们生成以”_”开头的成员变量，以及该变量的setter和getter方法。但是在Category中，我们无法用@property来添加属性，可以看下面的demo。 这里我们创建一个Person类和它的分类Person + Ext，然后在分类中声明一个属性，如下图 编译一下，会发现如下警告 这个警告的意思就是让我们手动去实现name的存取方法。这是由于分类是在运行时绑定方法的功能，而类属性需要在编译期确定，所以我们无法直接为category添加属性。不过通过AssoiatedObejct，我们可以间接实现这个需求。 Person+Ext.h12345#import &quot;Person.h&quot;@interface Person (Ext)@property (nonatomic, copy) NSString *name;@end Person+Ext.m1234567891011#import &quot;Person+Ext.h&quot;#import &lt;objc/runtime.h&gt;@implementation Person (Ext)-(void)setName:(NSString *)name &#123; objc_setAssociatedObject(self, @&quot;name&quot;, name, OBJC_ASSOCIATION_COPY);&#125;-(NSString *)name &#123; return objc_getAssociatedObject(self, @&quot;name&quot;);&#125; 使用了objc_setAssociatedObject以及 objc_setAssociatedObject 来实现property的存取方法，而使用关联对象模拟实例变量，从而达到为category添加属性的效果。 实际场景 项目中我们用associatedObject为UITextField添加了max_length属性，可以直接使用max_length来实现限制输入字符的效果，而不必每次都在UITextField的代理中写一大段代码来实现。 在DZNEmptyDataSet中，使用了setAssociatedObject，对scrollView的分类添加了EmptyDataSetSource的属性，在属性的setter方法中给reloadData注入了自己实现的dzn-reloadData，实现了无感知替换。]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS列表页无数据占位图]]></title>
    <url>%2F2016%2F03%2F23%2Fplaceholder%2F</url>
    <content type="text"><![CDATA[在项目开发中经常会碰到页面没有数据展示的情况，如果使用纯白的background给用户的感觉很不好，所以需要有一些占位图来起到提示的作用。比如像下面这样： 之前我们在项目里使用的是DZNEmptyDataSet，很好用的三方，有着和UITableView相似的API，用起来非常方便顺手。 不过还是想要自己实现一下这个功能，下面就是一些思路和实现方式。(以下以tebleview为例，collectionview同理) 核心思路就是：当tableView调用reloadData刷新时，检查tableView行数，如果为零，说明无数据，显示占位图。这里可以使用addSubView或者tableView的backgroundView来添加占位图。 要监测tableView行数是否为0，只需要利用dataSource，用isEmpty来标示是否为空数据，下面是核心代码 1234567891011121314151617181920212223-(void)checkEmpty &#123; BOOL isEmpty = YES; id&lt;UITableViewDataSource&gt; dataSource = self.tableView.dataSource; NSInteger sections = 1; if ([dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) &#123; sections = [dataSource numberOfSectionsInTableView:self.tableView] - 1;//获取当前TableView组数 &#125; for (NSInteger i = 0; i &lt;= sections; i++) &#123; NSInteger rows = [dataSource tableView:self.tableView numberOfRowsInSection:sections];//获取当前TableView各组行数 if (rows) &#123; isEmpty = NO;//若行数存在，不为空 &#125; &#125; if (isEmpty) &#123;//若为空，加载占位图 if (!self.placeholderView) &#123;//若未自定义，展示默认占位图 [self showDefaultPlaceholderView]; &#125; self.placeholderView.hidden = NO; [self.tableView addSubview:self.placeholderView]; &#125; else &#123;//不为空，隐藏占位图 self.placeholderView.hidden = YES; &#125;&#125; 上面这段代码就可以实现当dataSource为空时，为tableView添加占位图的功能。 不过每次都要在控制器里这么写，未免太冗余了，所以还是拿出我们的黑魔法Runtime Method Swizzling 给UITableView添加分类，在分类的+ (void)load方法中，通过Method Swizzling替换reloadData方法，给予它新的实现 123456789101112131415161718192021222324252627+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //方法交换，将reloadData实现交换为checkEmpty_reloadData [self replaceOriginalSEL:@selector(reloadData) withNewSEL:@selector(checkEmpty_reloadData)]; &#125;);&#125;+ (void)replaceSEL:(SEL)originSEL withNewSEL:(SEL)newSEL &#123; Class class = [self class]; Method originMethod = class_getInstanceMethod(class, originSEL); Method newMethod = class_getInstanceMethod(class, newSEL); BOOL didAddMethod = class_addMethod(class, originSEL, method_getImplementation(originMethod), method_getTypeEncoding(originMethod)); if (didAddMethod) &#123; class_replaceMethod(class, newSEL, method_getImplementation(originMethod), method_getTypeEncoding(originMethod)); &#125; else &#123; method_exchangeImplementations(originMethod, newMethod); &#125;&#125; - (void)checkEmpty_reloadData &#123; [self checkEmpty]; [self checkEmpty_reloadData];&#125; 这样就实现了tableView在reloadData的同时检测行数从而判断是否显示占位图的功能。 不过要注意的是，对于UITableView，还需要对endUpdates注入checkEmpty_reloadData方法。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于正则表达式]]></title>
    <url>%2F2016%2F01%2F25%2Fregex%2F</url>
    <content type="text"><![CDATA[iOS正则表达式的运用前言：在大部分app表单填写场景中，都会去校验用户输入的合法性，如果输入有误就提示错误信息并阻止上传到服务器。而这种功能就是由强大的正则表达式来实现的。 1正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 语法正则表达式是由两种基本字符组成：普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符” — metacharacter）所组成的描述文本规则的代码。规则用来描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为文本规则，将某个文本规则与所搜索的字符串进行匹配。 元字符元字符就是指那些在正则表达式中具有特殊意义的专用字符，用来规定其前导字符（位于元字符前面的字符）在目标对象中的出现规则，一个元字符可以用来匹配一个或者多个字符。 总结：元字符就是正则表达式中用来描述一个文本规则的专用字符。举例：精确查找“ab”在未使用正则表达式之前，查找ab，我们可能会得到以下结果 表一：常用的元字符 元字符 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等 \d 匹配数字(0-9) \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 限定符正则表达式中提供了有一类用于限定字符数量的符号，称为 限定符。并且限定符分为两种 ： 贪婪的：尝试尽可能多的匹配元素 惰性（非贪婪）的：尽可能的少的匹配元素 通过添加问号即 ？可以将贪婪限定符转为惰性限定符。从前面的综合例子中，大概已经知道了限定字符数量的字符 例如 ：* ，+，{2}… 表2 常用的限定符 贪婪限定符 惰性限定符 说明 * *? 重复零次或更多次 + *+ 重复一次或更多次 ? ?? 重复零次或一次 {n} {n}? 重复n次 {n,} {n,}? 重复n次或更多次 {n,m} {n,m}? 重复n到m次 正则表达式在iOS中的应用1.NSString的方法 123456- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask&#123;NSString *searchText = @&quot;rangeOfString&quot;;NSRange range = [searchText rangeOfString:@&quot;^[0-9]+$&quot; options:NSRegularExpressionSearch];if (range.location != NSNotFound) &#123; NSLog(@&quot;range ：%@&quot;, [searchText substringWithRange:range]);&#125; 2.NSPredicateCocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。 我们可以编写简单的谓词语句，就可以从数组中过滤出我们想要的数据。 代码示例: 12345+ (BOOL)validateEmail:(NSString *)email&#123; NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex]; return [emailTest evaluateWithObject:email];&#125; 3.NSRegularExpressionNSRegularExpression这个类是苹果专门封装的一个用来处理正则表达式的类。代码示例: 1234567objectivecNSString *searchText = @&quot;you want to match&quot;; NSError *error = NULL;NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&quot;^[0-9]+$&quot; options:NSRegularExpressionCaseInsensitive error:&amp;error];NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];if (result) &#123; NSLog(@&quot;%@&quot;, [searchText substringWithRange:result.range]);&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2015%2F12%2F21%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[LinuxLinux是一套免费使用和自由传播的类Unix操作系统（MacOS也是）。 它的基本思想是： 一切皆文件 除了普通文件，诸如目录、字符设备、块设备、套接字等在Unix/Linux中也都是以文件来对待，虽然类型不同，但是对其提供的却是同一套操作界面。不同的文件根据类型或用途放在不同的目录下。 由目的单一、短小、精悍的程序组成 通过短小、简单的程序保障linux的高效。 文本文件保存配置信息 使用简单的文件编辑器就可以完成配置、更改配置。 尽量避免捕获用户接口 一个程序一旦开始运行，就不需要用户进行任何操作，尽量不和用户交互。 shellshell翻译过来是壳的意思，它是包裹在linux内核外层的，一个可通过一系列的linux命令对操作系统发出相关指令的人机界面。 shell可以通过其条件语句和循环语句等，把一系列linux命令结合在一起，形成一个相当于面向过程的程序—shell script，来实现一些较为复杂的功能。 linux目录操作命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 ------目录的增、删、改、查------ cd, pwd, ls, mkdir, mv, ls(du, df, tree) 切换目录,跟window的使用类似 cd 显示目录的详细信息ls -ld直接切换到根目录cd /在根目录下创建oracle目录mkdir /oraclels -ld /oracledrwxr-xr-x 2 root root 4096 Jun 21 15:00 /oracle 一次创建多个目录mkdir -p /u01/app/oracle显示当前文件夹的路径pwd 删除oracle目录时显示确认rm -r /oracle删除oracle目录时不显示确认rm -rf /oracle把oracle目录名修改成oracle1mv /oracle oracle1把oracle目录移动到/tmp目录下mv /oracle /tmp显示某个目录的详细信息ls oracle -ld相看磁盘空间df -h df /tmp以树形式显示tmp目录的结构tree /tmp查看tmp文件夹下所有文件的路径du /tmp拷贝文件到某个目录cp source dest linux文件操作命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347------文件增，删，改，查------touch, cat, more, less, tail, head, rm -f, mv, cp, vi创建test文本文档touch testvi打开文件模式下，显示行号命令:set number查看test文档的内容cat test查看test文档的内容前10行head -10 test查看test文档的内容最后10行tail -10 test网络登录本地机器ssh localhost实时监控登录信息tail -f /var/log/messagestail -f /var/log/secure分页显示test文本内容，按空格键显示下一页，按q退出more test分页显示test文本内容，按空格键显示下一页，按q退出，按上下键进行上翻和下翻less testtest文件重命名为test1mv test test1把test文件移动到上一级目录下mv test ../把上一级文件test移动到当前目录mv ../test .把test1拷贝成test2cp test1 test2把一个目录拷贝成另一个目录cp -r hh dd删除test1文件并提示是否删除rm test1强制删除test1文件rm -f test1删除当前目录下所有文件rm -rf *备份某个文件cp test test.bak3. vi操作文件常用方式查看模式：G(shift+g) 跳到文件尾部gg 跳到文件首部/ 从文本尾部开始查找某个文本? 从文本首部开始查找某个文本dd 删除一行ndd 删除多行yy 复制一行nyy 复制多行p 粘贴一行或多行u 撤消上一个操作冒号模式 :w 保存:wq 保存并退出:x 保存并退出:q! 不保存退出 :wq! 强制保存并退出 :set number 显示行号编辑模式：a 当前字符的后面插入 i 当前位置插入 o 当前行后面追加一个新行后插入 不同模式之间切换ESC4. linux用户和组操作id oracle 查看用户信息cd /home ls -acat /etc/passwdcat /etc/shodawuseradd oracle 创建oracle用户useradd -u 501 oracle useradd -u 501 -g root oracleuseradd -h 查看useradd命令简略帮助man useradd 查看useradd命令详细帮助， 直接打开帮助文件，q退出usermod -u 502 oracle 修改用户信息usermod -g root oracleuserdel -r oracle 删除oracle用户passwd oracle 修改用户密码cat /etc/group 查看组信息groupadd -g 501 dba 添加组信息groupdel dba 删除组，如果组下面有用户，要先删除用户groupmod -g 502 dba 修改组的giduseradd -u 501 -g oinstall -G dba oracle 给用户添加多个组su - oracle 切换用户并切换用户的配置文件 su oracle 切换用户但不切换用户配置文件权限设置r w x4 2 1rwx r-x r-xuser group others 7 5 5root root otherschown oracle:oinstall /oracle 修改某个目录权限chown -R oracle:oinstall /oracle 修改某个目录及其子目录权限ls -ld /oracle 查看目录权限chmod -R 777 /oracle 设置目录为最大权限chmod -R 755 /oracle 修改oracle目录及其子目录权限为755chown用法用来更改某个目录或文件的用户名和用户组的chown 用户名:组名 文件路径（可以是就对路径也可以是相对路径）例1：chown root:root /tmp/tmp1就是把tmp下的tmp1的用户名和用户组改成root和root（只修改了tmp1的属组）.例2：chown -R root:root /tmp/tmp1就是把tmp下的tmp1下的所有文件的属组都改成root和root。chmod用法用来修改某个目录或文件的访问权限。语法：chmod [who] [+ | - | =] [mode] 文件名 命令中各选项的含义为： 操作对象who可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。 g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。 a 表示“所有（all）用户”。它是系统默认值。 操作符号可以是： + 添加某个权限。 - 取消某个权限。 = 赋予给定权限并取消其他所有权限（如果有的话）。 设置 mode 所表示的权限可用下述字母的任意组合： r 可读。 w 可写。 x 可执行。 X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。 s 在文件执行时把进程的属主或组ID置为该文件的文件属主。 方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。 t 保存程序的文本到交换设备上。 u 与文件属主拥有一样的权限。 g 与和文件属主同组的用户拥有一样的权限。 o 与其他用户拥有一样的权限。 文件名：以空格分开的要改变权限的文件列表，支持通配符。 5. linux软件的安装、解压缩，yum file a.tar.gz*.tartar -xvf a.tartar cvf a.tar a/*.tar.gztar -zcvf a.tar.gz atar -zxvf a.tar.gz*.gzgunzip a.gzgzip -6 a a.gz*.bz2tar -jxvf a.bz2tar -cjvf a a.bz2 *.cpiocpio -idmv &lt; a.cpio*.cpio.gzzcat a.cpio.gz | cpio -idmv*.zipunzip a.zip安装软件rpm -ivh file.rpm过滤安装好的带有zsh字符的软件rpm -qa|grep zsh卸载软件rpm -e file.el5查看所以已安装软件rpm -ga使用yum安装软件mount /dev/hdc /mntcp rhel-debuginfo.repo rhel5.repovi rhel5.repo6. linux主机名、网络配置、网络的查看设置网卡向导setup####################################Name eth0Device eth0Use DHCP []Static IP 192.168.12.100Netmask 255.255.255.0Default gateway IP 192.168.12.1###################################重启网卡/etc/init.d/network restart查看网络配置信息ifconfig ethoifconfig -aip aip add手动修改网络配置文件vi /etc/sysconfig/network-scripts################################################################Inter Corporation 82545EM Gigabit Ethernet Controller (Copper)DEVICE=eth0BOOTPROTO=noneHWADDR=00:0c:29:9e:72:f4ONBOOT=yesTYPE=EthernetNETMASK=255.255.255.0IPADDR=192.168.12.100GATEWAY=192.168.12.1###############################################################修改主机域名vi /etc/hosts##################################################127.0.0.1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6192.168.91.10 RHL5##################################################vi /etc/sysconfig/network########################NETWORKING=yesNETWORKING_IPV6=noHOSTNAME=RHL5GATEWAY=192.168.91.1#######################立即刷新系统设置su -手工修改域名hostname RHL5退出终端，重新打开检查IP是否设置成功ping 192.168.12.100检查域名是否设置成功ping RHL57.linux磁盘管理、存储配置命令（raw配置），多路径软件配置查看各个分区的信息fdisk -l 进入分区模式fdisk /dev/sda让分区操作立即生效partprobe格式化某个分区mkfs.ext3 /dev/sda5把分区mount到某个目录才能使用分区mount /dev/sda5 /mnt取消分区的mount操作umount /dev/sda5把分区映射到某个裸设备, 并增加dba权限cd /etc/udev/rules.dvi 60-raw.rules########################################################ACTION=="add", KERNEL=="sda5",RUN+="/bin/raw/raw1 %N"KERNEL=="raw*", OWNER="oracle" GROUP="dba", MODE="0660"########################################################start_udevraw -qacat 60-raw.rules8.ssh基本操作ssh重启/etc/init.d/sshd restartssh登录到远程机器ssh 192.168.21.100拷贝文件到远程主机某个目录scp -r /oracle 192.168.12.100:/tmp9.linux优化的命令终止指定进程kill -9 11024批量终止xxx进程kill -9 `ps -ef |grep xxx |grep -v grep |awk '&#123;print $2&#125;'`ps -ef |grep ora_ 查看进程df -h 查看磁盘空间free -m 查看内存vmstat 1 5 查看系统统计信息（包括cpu,mem,io等）10.top命令top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2015%2F11%2F09%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[既然是用Markdown写作，必然要了解一下它的语法规则。一开始用会不太习惯，不过相信多加练习用起来应该会比Word顺手很多。下面整理了一些最常用，最基本的Markdown语法。顺便说一下，我用的Markdown编辑器是Typora，非常简洁的一款编辑器，推荐给大家。 标题设置 通过在文字两边加上#，就可以实现标题的效果，两边#号的多少就代表了是几级标题，非常简洁明了，最多可设置六级标题。下面是效果 标题 块注释 通过在文字开头添加&gt;表示块注释。效果如下 ​ 斜体 通过在文字两边加上* 或者_ ， 即可实现斜体效果，如下 斜体 粗体 在文字两边加上**或者__，即可实现粗体效果，如下 加粗 删除线 在文字两边加上~~或者，即可实现删除线效果，如下 删除 行内代码，在文字两边加上”`”，即可实现行内代码效果 code 代码块 “12```代码块 链接: 网址链接：[网址名称]:(具体网址) 图片链接：![图片名称]（具体网址） 效果如下： Baidu 分割线 使用 --- 或者 *** 或者 * * * 表示水平分割线。 表格 使用|…|….|可以显示出表格，效果如下 ….. …. 有序列表 阿拉伯数字后面跟上.和空格，效果就如这篇文章的列表 无序列表 在文字开头添加(*, +, -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。效果如下 第一条 第二条 ​]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
