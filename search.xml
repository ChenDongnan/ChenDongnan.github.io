<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程与GCD思考]]></title>
    <url>%2F2018%2F12%2F25%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EGCD%E6%80%9D%E8%80%83%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[从MVC到MVVM]]></title>
    <url>%2F2018%2F11%2F26%2F%E4%BB%8EMVC%E5%88%B0MVVM%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS UI性能调优]]></title>
    <url>%2F2018%2F11%2F21%2FiOS%20UI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[趁着项目的短暂的空闲期，把最近关于iOS图形渲染优化的一些方法和经验记录在这里，也算是一个学习的总结，如果有帮助到读者的话就再好不过了。 ##基础知识## 其实网上关于iOS渲染机制的文章也是数不胜数，这里推荐几篇大牛的文章给大家参考学习，相信大家在看完后会对iOS渲染机制有更加深刻的理解，本文也就不再赘述这方面的知识。同时也非常推荐iOS Core Animation advanced techniques这本书，阅读之后受益匪浅。 iOS 开发：绘制像素到屏幕https://segmentfault.com/a/1190000000390012 深入理解 iOS Rendering Process https://juejin.im/post/5ad3f1cc6fb9a028d9379c5f?utm_source=gold_browser_extension 性能检测既然要进行优化，那么首先需要做的就是检测我们项目中当前的性能状况，苹果的Xcode自带的Instrument就可以很好的完成这项工作，使用方法也很简单。这里以最新版Xcode10为例子,点击Xcode-&gt;Open Developer Tool -&gt;Instruments，启动Instruments, 如下图，点击Core Animation模块会出现如下面板，在All Processes这里可以选择你想要测试的项目这里我选择了公司的项目，然后点击左上角的红圈，instrument就运行了，你会发现你手机上安装的该项目也会随之运行起来。然后就会出现上图，显示的是项目运行的FPS,以及GPU的利用率。当画面静止的时候，FPS为0。一般来说，FPS应当要大于45才不会显得卡顿。 影响FPS的因素是多样的, 这里我们只考虑UI方面的因素，我们可以在Xcode10工具栏的Debug -&gt; View Debugging -&gt; Rendering进行查看可以看到这里有很多Debug选项, 我们来看几个比较重要的 Color Blended Layers图层混色，就是多个视图的位置有重叠，视图本身又有透明度。重叠区域的每一个像素，GPU 需要算出一种新的颜色（混色）。混合计算的公式是：1234567891011121314贴一个苹果文档中的解释&gt;```objective-c&gt;The blend mode constants introduced in OS X v10.5 represent the Porter-Duff blend modes. The symbols in the equations for these blend modes are:&gt;&gt; * R is the premultiplied result&gt;&gt; * S is the source color, and includes alpha&gt;&gt; * D is the destination color, and includes alpha&gt;&gt; * Ra, Sa, and Da are the alpha components of R, S, and D&gt; R是结果色，S是包含透明度的源色，D是包含透明度的目标色，Sa是原色的透明度 如下图，绿色代表没有发生图层混色，红色代表发生了图层混色。图中的label2设置了alpha为0.5，因此触发了Color Blended; 我们通过给View设置一个不透明的背景色，来避免图层混色的发生。 关于Color Blended Layers有几个注意点 如果label中的内容包含中文，label实际渲染区域要大于label的size，最外层会多一个subLayer，所以即使设置背景色不透明，仍然会发生混色。因此，还需要添加masksToBounds = YES UIImageView不仅需要自身容器不透明，并且imageView包含的内容图片也必须是不透明的 如果使用的是CALayer，要把opaque属性设置成YES(默认是NO)。如果是用的UIView, opaque属性默认是YES。 Color Hits Green and Misses Red 这个选项是用来检测图像是否有光栅化(Rasterize)的，这个概念听起来是一头雾水，百度之; 光栅化即将矢量图形转化为位图（栅格图像） , Calayer有一个属性shouldRasterize，就是用来决定是否开启光栅化的。 放一个苹果的文档 1When true, the layer is rendered as a bitmap in its local coordinate space (&quot;rasterized&quot;), then the bitmap is composited into the destination (with the minificationFilter and magnificationFilter properties of the layer applied if the bitmap needs scaling). Rasterization occurs after the layer&apos;s filters and shadow effects are applied, but before the opacity modulation. As an implementation detail the rendering engine may attempt to cache and reuse the bitmap from one frame to the next. (Whether it does or not will have no affect on the rendered output.) When false the layer is composited directly into the destination whenever possible (however, certain features of the compositing model may force rasterization, e.g. adding filters). Defaults to NO. 当这个属性被设置为YES时，即开启了光栅化。它会将一个layer预先渲染成bitmap再加入到缓存中，layer的阴影等效果也会被保存到bitmap中，光栅化后会将图层绘制到一个屏幕外的图像，然后这个图像将会被缓存起来并绘制到实际图层的 contents 和子图层，对于有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧来更加高效。但是光栅化原始图像需要时间，而且会消耗额外的内存。 当我们开启光栅化后,需要注意几点问题： 如果我们更新已光栅化的layer,会造成大量的离屏渲染。 CALayer的光栅化选项的开启与否需要我们仔细衡量使用场景。它主要适用于设置阴影耗费资源比较多的静态内容，而对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费。例如TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可栅格化。则会造成大量的offscreen渲染,降低图形性能。 不要过度使用,系统限制了缓存的大小为2.5X Screen Size. 如果过度使用,超出缓存之后,同样会造成大量的offscreen渲染。 被光栅化的图片如果超过100ms没有被使用,则会被移除。 因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。 Color Offscreen-Rendered Yellow 离屏渲染 离屏渲染应该是经常听到的一次词了，简单来说就是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作，由于过程中需要切换context，性能消耗比较大。 CoreGraphics的上下文绘制，drawRect绘制，layer圆角/边框/阴影/抗锯齿/光栅化等都可能导致离屏渲染 (Core Graphics 的绘制API出发的离屏渲染不是那种GPU的离屏渲染，使用Core Graphics 绘制 API 是在 CPU 上执行，触发的是 CPU 的离屏渲染。) 在Debug选项中选中Color Offscreen-Rendered Yellow,就可以检测视图的离屏渲染情况。如下图所示，呈现黄色的部分为发生了离屏渲染。 经过真机测试，发现以下情况 在iOS9系统上, 对UIImageView/UILabel/Button,使用cornerRadius + masksToBounds/ClipToBounds会发生离屏渲染, 但是对于UIButton,只需要设置cornerRadius就可以实现圆角效果，不会发生离屏渲染。 在iOS11上, 对UIImageView/UILabel,使用cornerRadius + masksToBounds/ClipToBounds并不会触发离屏渲染，但是在设置了shadow之后会触发离屏渲染。 在查找了网上的一些资料后，了解到苹果在iOS9之后做了优化，减少了不必要的离屏渲染。 针设置圆角/阴影导致的离屏渲染的处理方式 如果方便的情况下，可以让设计师直接提供裁切好圆角的图片。 对于UIView，只设置CornerRadius,无需设置ClipToBounds就可以实现圆角效果，不会触发离屏渲染。 对于UILabel，只设置CornerRadius,无需设置ClipToBounds就可以实现圆角效果，不会触发离屏渲染；如果label有背景色，在iOS10以上系统，可以使用CornerRadius + ClipToBounds组合，10以下的系统，可以设置label.layer.backgroundColor来代替label.backgroundColor 对于UIImageView 如果只需要支持iOS10及更新版本的机型，那么大胆的使用cornerRadius + masksToBounds，不会触发离屏渲染； 10以下的机型，可以通过给UIImage添加Category，利用UIBezierPath来实现。 12345678910111213- (UIImage*)imageAddCornerWithRadius:(CGFloat)radius andSize:(CGSize)size&#123; CGRect rect = CGRectMake(0, 0, size.width, size.height); UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale); CGContextRef ctx = UIGraphicsGetCurrentContext(); UIBezierPath * path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)]; CGContextAddPath(ctx,path.CGPath); CGContextClip(ctx); [self drawInRect:rect]; CGContextDrawPath(ctx, kCGPathFillStroke); UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; ​ 对于UIButton，如果只需要实现文字 + 圆角效果，那么用ConerRadius就可以了；如果要实现有图片的Button的圆角效果, 可以先参照上述方法先对图片进行处理。 对于简单阴影，可以使用CGContexRef/UIBezierPath绘制阴影路径并设置给ShadowPath来代替shadowOffset等属性设置阴影，下面是关于shadowPath的官方解释 12345imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0;imageView.layer.shadowRadius = 2.0;UIBezierPath *path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 以上就是对于UI的一些性能优化方法。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目启动时间优化]]></title>
    <url>%2F2017%2F08%2F22%2Fstart-time%2F</url>
    <content type="text"><![CDATA[一个App整理一些启动时间优化的方法。 首先需要知道当我们点击手机屏幕上App的图标，到App的首页呈现在面前，系统经历了怎样的过程。这里以main函数为分界，将启动过程分成main函数前和main函数后两个阶段。 main函数前 1.1. 加载应用的可执行文件（自身App的所有.o文件的集合）1.2. 加载动态链接库加载器dyld（dynamic loader）1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库，动态链接库包括：iOS中用到的所有系统framework,加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch（GCD）和libsystem_blocks(Block))。 Image与ImageLoader image表示一个二进制文件（可执行文件或so文件），里面是被编译过的符号、代码等，imageLoader的作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 main函数后 2.1. dyld调用main()2.2. 调用UIApplicationMain()2.3. 调用applicationWillFinishLaunching2.4. 调用didFinishLaunchingWithOptions 要查看main函数前启动时间，可以通过Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量DYLD_PRINT_STATISTICS 设为1 ： main阶段函数 main函数前的优化 从之前的图中可以看到main函数前主要经历了 Load dylibs 1.分析所依赖的动态库 2.找到动态库对应的mach-o文件 3.打开文件 4.验证文件 5.在系统核心注册文件签名 6.对动态库的每一个segment他调用mmap() 针对这一步可做的优化： 减少非系统库的依赖 合并非系统库 使用静态资源 Rebase/Bind Rebase : 在镜像内部调整指针的指向 在过去，会把dylib加载到指定地址，所有指针和数据对于代码来说都是对的，dyld就无需做任何fix-up了，使用了ASLR（Address space layout randomization）后，会将dylib加载到新的随机地址（actual_address),这个随机地址跟代码和数据指向的旧地址(preferred_address)会有偏差,dyld需要修正这个偏差（slide），做法就是将dylib内部的指针地址都加上这个偏移量，偏移量 Slide = actual_address - preferred_address ​ Bind : 将指针指向镜像外部的内容 是指处理那些指向dylib外部的指针，他们实际上被符号（symbol）名称绑定。dyld需要找到symbil对应的实现。 ​ ImageLoader是一个用于加载可执行文件的基类，它负责链接镜像。 每个可执行文件都会对应一个ImageLoader子类 针对这一步： 减少Objc类数量，减少selector数量 减少C++虚函数数量 使用swiif stuct（减少符号数量） Objc setup 这一步的主要工作是： 注册Objc类 把category的定义插入方法列表 保证selector的唯一性 针对这一步的优化其实在上一步就已经完成了 Initializers Objc的+load()函数 C++的构造属性函数 使用+initialize来替代+load 删除无用的库，文件 main()函数之后的优化 执行main()函数的耗时 执行applicationWillFinishLauching耗时 rootViewController及其childViewController的加载 ​ 延迟一些第三方库的加载]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook/chisel]]></title>
    <url>%2F2017%2F07%2F19%2Ffacebook-chisel%2F</url>
    <content type="text"><![CDATA[前几天看了一篇关于LLDB的文章https://www.objc.io/issues/19-debugging/lldb-debugging/，才发现它的功能如此强大。之前只会使用po这样简单的功能，实在是浪费了LLDB在调试中所能发挥的巨大作用。Facebook有一个开源项目chisel，Github地址：https://github.com/facebook/chisel#installation，对LLDB命令进一步封装，提供了一些非常方便的调试功能。 安装按照官网提示 12brew updatebrew install 安装完成后提示 12```Add the following line to ~/.lldbinit to load chisel when Xcode launches: command script import /usr/local/Cellar/chisel/1.5.0/libexec/fblldb.py 意思是需要将command script import /usr/local/Cellar/chisel/1.5.0/libexec/fblldb.py 这段代码加到./lldbinit中，这样每次LLDB启动时都会执行这段python脚本。 常用命令pviews 可以打印view的层级 pvc 打印viewcontrroller的层级 show&amp;hide 显示和隐藏一个指定的UIView fv&amp;fvc 通过类名搜索内存中存在的view和viewcontroller实例 mask/unmask 给view或者layer覆盖/移除mask border/unborder 给view或者layer添加/去掉border caflush 重新绘制界面，比如在控制台修改view的backgroundColor，调用caflush就可以直接看到背景色的改变 bmessage 提供打断点功能。一般我们打断点都会选择在行标上打，但比如我们想在[OneViewController viewWillAppear:]里打断点，但它并没有实现viewWillAppear:这个方法, 这时我们就可以通过 (lldb) bmessage -[OneViewController viewWillAppear:] ,这个命令会在其父类的viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[OneViewController class]] 以上就是chisel的一些常用命令，当然你也可以自定义python脚本去实现你想要的功能。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解UIView的绘制(转)]]></title>
    <url>%2F2017%2F05%2F23%2F%E7%90%86%E8%A7%A3UIView%E7%9A%84%E7%BB%98%E5%88%B6-%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[本文转自 http://vizlabxt.github.io/blog/2012/10/22/UIView-Rendering/ 理解UIView的绘制UIView是如何显示到Screen上的 也许要先从Runloop开始说，iOS的mainRunloop是一个60fps的回调，也就是说每16.7ms会绘制一次屏幕，这个时间段内要完成view的缓冲区创建，view内容的绘制（如果重写了drawRect），这些CPU的工作。然后将这个缓冲区交给GPU渲染，这个过程又包括多个view的拼接(compositing)，纹理的渲染（Texture）等，最终显示在屏幕上。因此，如果在16.7ms内完不成这些操作，比如，CPU做了太多的工作，或者view层次过于多，图片过于大，导致GPU压力太大，就会导致“卡”的现象，也就是丢帧。 苹果官方给出的最佳帧率是：60fps，也就是1帧不丢，当然这是理想中的绝佳的体验。 这个60fps改怎么理解呢？一般来说如果帧率达到25+fps，人眼就基本感觉不到停顿了，因此，如果你能让你ios程序稳定的保持在30fps已经很不错了，注意，是“稳定”在30fps，而不是，10fps，40fps，20fps这样的跳动，如果帧频不稳就会有卡的感觉。60fps真的很难达到，尤其在iphone4，4s上。 总的来说，UIView从绘制到Render的过程有如下几步： 每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store。 UIView的绘制和渲染是两个过程，当UIView被绘制时，CPU执行drawRect，通过context将数据写入backing store 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上 上面提到的从CPU到GPU的过程可用下图表示： 下面具体来讨论下这个过程 CPU bound：假设我们创建一个UILabel： UILabel* label = [[UILabel alloc]initWithFrame:CGRectMake(10, 50, 300, 14)];label.backgroundColor = [UIColor whiteColor];label.font = [UIFont systemFontOfSize:14.0f];label.text = @&quot;test&quot;;[self.view addSubview:label]; 这个时候不会发生任何操作，由于UILabel重写了drawRect，因此，这个view会被marked as “dirty”： 类似这个样子： 然后一个新的Runloop到来，上面说道在这个Runloop中需要将界面渲染上去，对于UIKit的渲染，Apple用的是它的Core Animation。 做法是在Runloop开始的时候调用： [CATransaction begin] 在Runloop结束的时候调用 [CATransaction commit] 在begin和commit之间做的事情是将view增加到view hierarchy中，这个时候也不会发生任何绘制的操作。 当[CATransaction commit]执行完后，CPU开始绘制这个view： 首先CPU会为layer分配一块内存用来绘制bitmap，叫做backing store 创建指向这块bitmap缓冲区的指针，叫做CGContextRef 通过Core Graphic的api，也叫Quartz2D，绘制bitmap 将layer的content指向生成的bitmap 清空dirty flag标记 这样CPU的绘制基本上就完成了。 通过time profiler 可以完整的看到个过程： Running Time Self Symbol Name2.0ms 1.2% 0.0 +[CATransaction flush]2.0ms 1.2% 0.0 CA::Transaction::commit()2.0ms 1.2% 0.0 CA::Context::commit_transaction(CA::Transaction*)1.0ms 0.6% 0.0 CA::Layer::layout_and_display_if_needed(CA::Transaction*)1.0ms 0.6% 0.0 CA::Layer::display_if_needed(CA::Transaction*)1.0ms 0.6% 0.0 -[CALayer display]1.0ms 0.6% 0.0 CA::Layer::display()1.0ms 0.6% 0.0 -[CALayer _display]1.0ms 0.6% 0.0 CA::Layer::display_()1.0ms 0.6% 0.0 CABackingStoreUpdate_1.0ms 0.6% 0.0 backing_callback(CGContext*, void*)1.0ms 0.6% 0.0 -[CALayer drawInContext:]1.0ms 0.6% 0.0 -[UIView(CALayerDelegate) drawLayer:inContext:]1.0ms 0.6% 0.0 -[UILabel drawRect:]1.0ms 0.6% 0.0 -[UILabel drawTextInRect:] 假如某个时刻修改了label的text： label.text = @&quot;hello world&quot;; 由于内容变了，layer的content的bitmap的尺寸也要变化，因此这个时候当新的Runloop到来时，CPU要为layer重新创建一个backing store，重新绘制bitmap。 CPU这一块最耗时的地方往往在Core Graphic的绘制上，关于Core Graphic的性能优化是另一个话题了，又会牵扯到很多东西，就不在这里讨论了。 GPU bound：CPU完成了它的任务：将view变成了bitmap，然后就是GPU的工作了，GPU处理的单位是Texture。 基本上我们控制GPU都是通过OpenGL来完成的，但是从bitmap到Texture之间需要一座桥梁，Core Animation正好充当了这个角色： Core Animation对OpenGL的api有一层封装，当我们的要渲染的layer已经有了bitmap content的时候，这个content一般来说是一个CGImageRef，CoreAnimation会创建一个OpenGL的Texture并将CGImageRef（bitmap）和这个Texture绑定，通过TextureID来标识。 这个对应关系建立起来之后，剩下的任务就是GPU如何将Texture渲染到屏幕上了。 GPU大致的工作模式如下： 整个过程也就是一件事：CPU将准备好的bitmap放到RAM里，GPU去搬这快内存到VRAM中处理。 而这个过程GPU所能承受的极限大概在16.7ms完成一帧的处理，所以最开始提到的60fps其实就是GPU能处理的最高频率。 因此，GPU的挑战有两个： 将数据从RAM搬到VRAM中 将Texture渲染到屏幕上 这两个中瓶颈基本在第二点上。渲染Texture基本要处理这么几个问题： Compositing：Compositing是指将多个纹理拼到一起的过程，对应UIKit，是指处理多个view合到一起的情况，如 [self.view addsubview : subview]。 如果view之间没有叠加，那么GPU只需要做普通渲染即可。 如果多个view之间有叠加部分，GPU需要做blending。 加入两个view大小相同，一个叠加在另一个上面，那么计算公式如下： R = S+D*(1-Sa) R: 为最终的像素值 S: 代表 上面的Texture（Top Texture） D: 代表下面的Texture(lower Texture) 其中S,D都已经pre-multiplied各自的alpha值。 Sa代表Texture的alpha值。 假如Top Texture（上层view）的alpha值为1，即不透明。那么它会遮住下层的Texture。即,R = S。是合理的。 假如Top Texture（上层view）的alpha值为0.5，S 为 (1,0,0)，乘以alpha后为(0.5,0,0）。D为(0，0，1)。 得到的R为（0.5，0，0.5）。 基本上每个像素点都需要这么计算一次。 因此，view的层级很复杂，或者view都是半透明的（alpha值不为1）都会带来GPU额外的计算工作。 Size这个问题，主要是处理image带来的，假如内存里有一张400x400的图片，要放到100x100的imageview里，如果不做任何处理，直接丢进去，问题就大了，这意味着，GPU需要对大图进行缩放到小的区域显示，需要做像素点的sampling，这种smapling的代价很高，又需要兼顾pixel alignment。计算量会飙升。 Offscreen Rendering And Mask如果我们对layer做这样的操作： label.layer.cornerRadius = 5.0f;label.layer.masksToBounds = YES; 会产生offscreen rendering,它带来的最大的问题是，当渲染这样的layer的时候，需要额外开辟内存，绘制好radius，mask，然后再将绘制好的bitmap重新赋值给layer。 因此继续性能的考虑，Quartz提供了优化的api： label.layer.cornerRadius = 5.0f;label.layer.masksToBounds = YES;label.layer.shouldRasterize = YES;label.layer.rasterizationScale = label.layer.contentsScale; 简单的说，这是一种cache机制。 同样GPU的性能也可以通过instrument去衡量： 红色代表GPU需要做额外的工作来渲染View，绿色代表GPU无需做额外的工作来处理bitmap。 That’s all]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage Cache Mechanism]]></title>
    <url>%2F2017%2F04%2F19%2FSDWebImage-Cache-Mechanism%2F</url>
    <content type="text"><![CDATA[SDWebImage是很多项目中都会用到的三方库。这篇文章用来记录下学习SDWebImage图片缓存机制的心得。 SDWebImageCacheConfig，正如其名，主要缓存策略的配置选项，比如最大缓存容量、缓存过期时间，读取缓存选项等，比较简单。 SDWebImageCache 1234567891011121314typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; /** * The image wasn&apos;t available the SDWebImage caches, but was downloaded from the web. */ SDImageCacheTypeNone, /** * The image was obtained from the disk cache. */ SDImageCacheTypeDisk, /** * The image was obtained from the memory cache. */ SDImageCacheTypeMemory&#125;; 在SDWebImageCache头文件里，可以看到有三种缓存策略,SDImageCacheTypeNone，SDImageCacheTypeDisk，SDImageCacheTypeMemory 分别是不使用缓存，硬盘缓存和内存缓存。 当我们使用SDImage加载图片是，往往会用到SDWebImage的扩展 [imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;https://pic.tugou.com/material/1476243549_0622559.jpg&quot;]];, 这个方法会调用SDWebImageManager的downloadImageWithURL 123id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; &#125;]; SDWebImageManager 内部的 downloadImageWithURL方法会先使用我们前面提到的 SDImageCache 类的 queryDiskCacheForKey 方法，查询图片缓存： 123operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123; ...&#125;]; queryDiskCacheForKey 方法会先查询是否存在Memory cahce 123- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123; return [self.memCache objectForKey:key];&#125; 12345678910111213141516- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123; // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; return image; &#125; // Second check the disk cache... UIImage *diskImage = [self diskImageForKey:key]; if (diskImage) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; return diskImage;&#125; LRU算法]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dictionary to Model]]></title>
    <url>%2F2017%2F03%2F22%2FDictionary-to-Model%2F</url>
    <content type="text"><![CDATA[字典转模型，这是每个项目中都需要用到的功能，我们项目中使用MJExtension来实现相关功能。之前自己也简单写过一个demo，不过没有完整的去实现这个功能，这次打算写一个来练练手。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime之methodSwizzling]]></title>
    <url>%2F2017%2F03%2F18%2Fruntime%E4%B9%8BmethodSwizzling%2F</url>
    <content type="text"><![CDATA[Method swizzling被称为runtime的黑魔法，那么之所以被称为黑魔法，一方面有其强大之处，另一方面用的不好也会产生意想不到的问题，所以在使用method swizzling的时候一定要慎重考虑。 Mthod swizzling，字面翻译就是方法交换，它可以允许我们动态地替换方法的实现。很多项目中都会用到埋点，记录每个页面的呈现次数。那么就需要我们在控制器中的viewDidAppear方法中去添加记录代码。这个功能可以通过写一个父类控制器，在父类viewDidAppear里添加记录代码，其他的控制器都继承与该父类控制器来实现。但是这么做的话，你需要UIViewController，UITableViewController，UINavigationController中都实现他们的viewDidAppear方法，比较繁琐。这时候，使用method swizzling也不失为一种好方法。 首先要分清几个概念: Selectors,Methods,Implementations Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 Implementation（typedef id (*IMP)(id, SEL,...)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象metaclass）。第二个参数是这个方法的名字selector，该方法的真正参数紧随其后。 理解 selector, method, implementation 这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。 Method swizzling常用的API : class_addMethod(Class cls, SEL name, IMP imp, const char *types);```12```Method class_getInstanceMethod(Class cls, SEL name); class_getClassMethod(Class cls, SEL name);```12```IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types); class_getMethodImplementation(Class cls, SEL name);```12```method_exchangeImplementations 使用method swizzling和category来添加统计方法 首先给UIViewController添加一个category，然后去重写+(void)load方法，因为该方法在类被加载到内存时会且仅会被调用一次。 123456789101112131415161718192021222324252627282930313233343536373839#import &lt;objc/runtime.h&gt;@implementation UIViewController (swizzling)+ (void)load &#123; // 通过class_getInstanceMethod()函数从当前对象中的method list获取method结构体，如果是类方法就使用class_getClassMethod()函数获取。 Method fromMethod = class_getInstanceMethod([self class], @selector(viewDidLoad)); Method toMethod = class_getInstanceMethod([self class], @selector(swizzlingViewDidLoad)); /** * 使用class_addMethod()函数对Method Swizzling做了一层验证，如果self没有实现被交换的方法，会导致失败。 * 而且self没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。 * 所以我们在这里通过class_addMethod()的验证，如果self实现了这个方法，class_addMethod()函数将会返回NO，我们就可以对其进行交换了。 */ if (!class_addMethod([self class], @selector(swizzlingViewDidLoad), method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) &#123; method_exchangeImplementations(fromMethod, toMethod); &#125;&#125;// 我们自己实现的方法，也就是和self的viewDidLoad方法进行交换的方法。- (void)swizzlingViewDidLoad &#123; NSString *str = [NSString stringWithFormat:@&quot;%@&quot;, self.class]; // 我们在这里加一个判断，将系统的UIViewController的对象剔除掉 if(![str containsString:@&quot;UI&quot;])&#123; NSLog(@&quot;埋点 : %@&quot;, self.class); &#125; [self swizzlingViewDidLoad];&#125;@end 通过上述操作，当一个继承自UIViewController类的类被加载的时候，就会执行(void) swizzlingViewDidLoad，从而实现了添加统计代码的功能。 另外，利用method swizzling 也可以来防止一些意外崩溃。比如我们往数组或者字典中插入nil对象引起的崩溃，或者数组越界的崩溃，都可以用method swizzling来避免。 对字典进行method swizzling 1234567891011121314151617181920212223@implementation NSDictionary (Safe)+ (void)load &#123; Method originalMethod = class_getClassMethod(self, @selector(dictionaryWithObjects:forKeys:count:)); Method swizzledMethod = class_getClassMethod(self, @selector(safe_dictionaryWithObjects:forKeys:count:)); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;+ (instancetype)safe_dictionaryWithObjects:(const id [])objects forKeys:(const id &lt;NSCopying&gt; [])keys count:(NSUInteger)cnt &#123; id nObjects[cnt]; id nKeys[cnt]; int i=0, j=0; for (; i&lt;cnt &amp;&amp; j&lt;cnt; i++) &#123; if (objects[i] &amp;&amp; keys[i]) &#123; nObjects[j] = objects[i]; nKeys[j] = keys[i]; j++; &#125; &#125; return [self safe_dictionaryWithObjects:nObjects forKeys:nKeys count:j];&#125;@end 12345678910111213141516@implementation NSMutableDictionary (Safe)+ (void)load &#123; Class dictCls = NSClassFromString(@&quot;__NSDictionaryM&quot;); Method originalMethod = class_getInstanceMethod(dictCls, @selector(setObject:forKey:)); Method swizzledMethod = class_getInstanceMethod(dictCls, @selector(na_setObject:forKey:)); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;- (void)na_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey &#123; if (!anObject) return; [self na_setObject:anObject forKey:aKey];&#125;@end 同样的，对数组也可以采取类似的方法。 可以看到，method swizzling的功能十分强大，不过使用时要注意]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime之AssosiatedObject]]></title>
    <url>%2F2017%2F02%2F23%2Fruntime%E4%B9%8BassociatedObject%2F</url>
    <content type="text"><![CDATA[iOS runtime特性真的是十分强大，虽然项目中直接使用的不多，但很多三方里面都有用到相关内容，所以也是在此记录一下runtime的相关知识点，因为确实很多，所以把它们整理成了几个部分。第一篇就写点关于关联对象（AssociatedObject）相关内容。 在object/runtime.h文件中，找到相关API 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Sets an associated value for a given object using a given key and association policy. * * @param object The source object for the association. * @param key The key for the association. * @param value The value to associate with the key key for object. Pass nil to clear an existing association. * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.” * * @see objc_setAssociatedObject * @see objc_removeAssociatedObjects */OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);/** * Returns the value associated with a given object for a given key. * * @param object The source object for the association. * @param key The key for the association. * * @return The value associated with the key \e key for \e object. * * @see objc_setAssociatedObject */OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);/** * Removes all associations for a given object. * * @param object An object that maintains associated objects. * * @note The main purpose of this function is to make it easy to return an object * to a &quot;pristine state”. You should not use this function for general removal of * associations from objects, since it also removes associations that other clients * may have added to the object. Typically you should use \c objc_setAssociatedObject * with a nil value to clear an association. * * @see objc_setAssociatedObject * @see objc_getAssociatedObject */OBJC_EXPORT void objc_removeAssociatedObjects(id object) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0); 以及枚举类型的引用策略： 123456789101112131415/** * Policies related to associative references. * These are options to objc_setAssociatedObject() */typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; API解析 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) API可以为两个对象建立起关联 id object ：关联者 id value : 被关联者 const void *key : 被关联者的key，可以通过该key获取该关联者 objc_AssociationPolicy policy ：表示被关联者的引用策略，也就是内存管理，通过上面的枚举来设置。 id objc_getAssociatedObject(id object, const void *key) API可以通过事先设置的Key获取被关联对象 id object ：关联者 const void *key : 被关联者的key void objc_removeAssociatedObjects(id object) 该 API 可以移除一个 关联者 对象所有的 被关联者。当需要移除特定的对象时，我们可以使用objc_setAssociatedObject方法并指定 id value 参数对象为空即可。 AssosiatedObject的使用 明白了API的意思后，就需要深入到我们实际的应用了。 为category添加变量 category可以为已经存在的类添加方法，但是无法添加属性。不过通过AssoiatedObejct，我们可以实现这一点。 NSObject+AssociatedObject.h12345@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m123456789101112131415@dynamic associatedObject;static char kAssociatedObjectKey;- (void)setAssociatedObject:(id)object &#123; objc_setAssociatedObject(self, &amp;kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)associatedObject &#123; return objc_getAssociatedObject(self, &amp;kAssociatedObjectKey));&#125; 使用了objc_getAssociatedObject 以及 objc_setAssociatedObject 来模拟『属性』的存取方法，而使用关联对象模拟实例变量，从而达到为category添加属性的效果。 在一些特殊场景下，比如想知道一个系统内部对象或者第三方对象是何时被释放时，我们可以为该对象关联一个自定义的对象，并且使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 来指定内存管理策略，当关联者被释放是，被关联者也会跟着被释放，这样可以在我们自定义的对象中，知道感兴趣的对象何时被释放的。在调试一些内存问题时，该方法还是蛮有用的。 关联对象应该被当做最后的手段来使用（不得不用时才用），要在完全理解其的基础上再进行使用，否则可能会造成意想不到的后果。]]></content>
      <categories>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程与王者荣耀]]></title>
    <url>%2F2017%2F02%2F16%2F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%2F</url>
    <content type="text"><![CDATA[最近被同事带着玩了王者荣耀。 玩的过程中突然想到一点。 一个英雄，你看再多的介绍、攻略、视频，都不如上手实战几把熟悉得快。 编程也是，看再多的技术文章都不如实际上手敲几行代码来的有用。当然理论学习还是很必要的，不过在学习之前，先实战，遇到坑，再去深入学习，我觉得这样可能效果会更佳。]]></content>
      <tags>
        <tag>瞎话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI Test]]></title>
    <url>%2F2017%2F02%2F05%2FUI-Test%2F</url>
    <content type="text"><![CDATA[UI Tests是什么？UI Tests是一个自动测试UI与交互的Testing组件 UI Tests有什么用？它可以通过编写代码、或者是记录开发者的操作过程并代码化，来实现自动点击某个按钮、视图，或者自动输入文字等功能。 UI Tests的重要性在实际的开发过程中，随着项目越做越大，功能越来越多，仅仅靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UI Tests就可以帮助解决这个问题了 使用方法第一步：添加UI Tests如果是新项目，则创建工程的时候可以直接勾选选项，如下图 如果是已有项目，可以通过添加target的方法添加一个UI Test 第二步：创建测试代码手动创建测试代码打开测试文件，在testExample()方法中添加测试代码 如果不知道如何写测试代码，则可以参考自动生成的代码样式 自动生成测试步骤 选择测试文件后，点击录制按钮 这时候开始进行操作，它会记录你的操作步骤，并生成测试代码下图就是在一些操作后自动生成的测试代码 时候可以分析测试代码的语法，以便你自己手动修改或者手写测试代码 开始测试点击testExample方法旁边的播放按钮，它就开始进行自动测试了，这时候你会看到app在自动操作 下面介绍一下测试元素的语法XCUIApplication：继承XCUIElement，这个类掌管应用程序的生命周期，里面包含两个主要方法launch():启动程序terminate():终止程序 XCUIElement: 继承NSObject，实现协议XCUIElementAttributes, XCUIElementTypeQueryProvider可以表示系统的各种UI元素exist:可以让你判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试descendantsMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:取某种类型的元素以及它的子类集合childrenMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:取某种类型的元素集合，不包含它的子类 这两个方法的区别在于，你仅使用系统的UIButton时，用childrenMatchingType就可以了，如果你还希望查询自己定义的子Button，就要用descendantsMatchingType 另外UI元素还有一些交互方法tap():点击doubleTap():双击pressForDuration(duration: NSTimeInterval):长按一段时间，在你需要进行延时操作时，这个就派上用场了swipeUp():这个响应不了pan手势，暂时没发现能用在什么地方，也可能是beta版的bug，先不解释typeText(text: String):用于textField和textView输入文本时使用，使用前要确保文本框获得输入焦点，可以使用tap()函数使其获得焦点]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS签名原理学习记录]]></title>
    <url>%2F2016%2F05%2F11%2FiOS-signature-and-certificate%2F</url>
    <content type="text"><![CDATA[iOS签名机制一直是很困扰我的一件事，真机测试或者打包的时候，经常会遇到各种情况的报错，CertificateRequest,p12,Provision Profile,Code Sign五花八门的，所以在这里系统地记录一下相关知识，不再一知半解地去处理这些问题。 对称加密对称加密就是指加密和解密使用同一个密钥的加密方式。 举个简单的例子 密钥 ：X 加密算法 ：每个数字 + X 明文 ： 12345 密钥X为1，那么加密结果就是23456； 对称加密使得对密钥的保管显得尤为重要，如果传输过程中密钥泄漏，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。 非对称加密非对称加密有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。 非对称加密算法中最常见的应该就是RSA了,简单介绍下RSA 选两个质数 p 和 q，相乘得出一个大整数n，例如 p = 19，q = 7，n = pq = 133 选 1-n 间的随便一个质数e，例如 e = 11 经过一系列数学公式，算出一个数字 d，满足：a.通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。b.如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。 上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用私钥加密，公钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥 (只知道 n 和 e)的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而 n 数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。 苹果为了确保安装到用户手机上的App都是被官方认证过的，苹果推出了签名机制，那么这个签名又是什么呢？ 数字签名对于某份账单或者文件之类的东西，如果它得到了我的确认，我就会用签名来表示我同意了。那么数字签名也一样，它的作用是我对某一份数据打个标记（就像签名一样），表示我认可了这份数据，然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。 有了上述的非对称加密算法，就可以实现这个需求： 首先用一种算法(这里用md5举例)，算出原始数据的摘要。 生成一份非对称加密的公钥和私钥，私钥自己保管，公钥公布出去。 对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。 用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。 之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位 / 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。 了解了什么是数字签名，就可以更好地理解苹果是如何通过数字签名机制来确保安装到iPhone的App都是经过苹果认证的。 方案一 如上图所示，最简单的方案，就是由苹果生成一堆公私钥，在iOS设备里内置一个公钥，在苹果后台保存一份私钥，但App上传到AppStore时，苹果用私钥对App进行数字签名。iOS设备下载App后，用公钥进行解密验证，若相等，则说明App是由苹果官方认证的。 这个方案非常简洁明了，但是有一个缺点，因为除了AppStore外，我们还有其他方法可以安装App 安装开发版本App对于开发者来说，如果每次调试app还需要把安装包传到Apple后台签名，那肯定是不能忍的。但是苹果也想要对这部分App有控制权，不能被滥用导致非开发app也能被安装。因此就有了如下的解决方案 在mac上生成一对公私钥，图里标示为公钥L，私钥L，L代表Local的意思 苹果自己也生成一对公私钥，私钥在苹果后台，公钥在每个iOS设备上，标示为公钥L，私钥A， A代表Apple 把公钥L传给苹果后台，用私钥A对公钥L进行签名，得到一份包含了公钥L以及其签名的数据，称为证书。 在开发中，编译完一个App后，通过本地的私钥L对App进行签名，同时把第三部得到的证书一起打包进App 在安装时，通过iOS系统内置的公钥A，去解密第三步用私钥A加密的数据，来验证证书的数字签名是否正确 验证证书后，确保了公钥L是苹果认证的，再用公钥L去验证App的签名,这里就间接验证了这个app的安装行为是经过苹果允许的（这里只验证安装行为，不验证App是否被改动，因为在开发阶段App是不断变化的） 上述流程解决了开发版本App需要经过苹果认证，但是还没有解决可能存在的滥用问题，于是苹果又加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某个具体App。 在上述第三步用私钥A签名公钥L之外，也可以加上其他数据，这些数据都可以保证是经过苹果官方认证的，不会被篡改。 把AppID和允许安装的设备ID列表等数据，在第三步的时候和公钥L一起组成证书，用私钥A进行签名，在第五步 r如果通过验证,就可以确定拿到的设备ID列表/AppID/公钥L是经过苹果认证的，这样就避免了滥用。 最终流程除了上述情况外，苹果还想要控制App里的iCloud/Push等等，苹果把这些权限开关统一称为Entitlements，它也需要通过签名授权。 把各种信息塞入到证书是不符合规范的，因此，苹果又搞了个叫做Provision Profile的东西，它就包括了证书以及上述提到的所有额外信息以及信息的签名。 所以整个流程又变为 再来看一下整个流程 在mac上生成一对公私钥，图里标示为公钥L，私钥L，L代表Local的意思 苹果自己也生成一对公私钥，私钥在苹果后台，公钥在每个iOS设备上，标示为公钥L，私钥A， A代表Apple 把公钥L传给苹果后台，用私钥A对公钥L进行签名，得到一份包含了公钥L以及其签名的数据，称为证书。 在苹果后台申请AppID，配置好设备ID和App的各项权限，再加上第三部生成的证书，组成的数据用私钥A签名后，把数据和签名一起组成一个Provision Profile文件，下载到本地。 在开发时，编译完一个App后，用私钥L对App进行签名，同时把第四步得到的Probvision Profile文件打包进App里，文件名为embeded.mobileprovision，把App安装到手机上。 在安装时，iOS系统去的证书，通过私钥A去验证embedded.mobileprovision的数字签是否正确，证书签名也会验证一遍 确保embedded.mobileprovision里的数据都是苹果授权的之后，就可以取出数据，来验证数据是否符合要求如设备ID是否在设备列表上，AppID是否对应，权限开关是否对应等。 相关操作上面的步骤对应我们的具体操作和概念如下： 第1步对应的是在Mac上的keychain中，从证书颁发机构请求证书。这里就生成了公钥L和私钥L，保存的CertificateSigningRequest就是公钥，私钥则保存在本地电脑中。 第2步是由苹果处理 第3步对应把CertificateSigningRequest传到苹果后台生成证书，并下载到本地。这是本地有两个证书，一个是第一步生成的，一个是这边下载的。keychain会这两个证书关联起来，因为他们的公私钥是对应的。在Xcode选择证书时，实际上会找到keychain里对应的私钥去签名。这里私钥只有生成它的Mac本地有，如果别的Mac也想要编译签名这个App，就需要把私钥导出给其他Mac使用。在keychain里导出私钥会生成一个.p12文件，其他Mac打开这个文件后就导入了这个私钥。 这一步是在苹果开发者官网操作的，配置AppID/权限/设备等，最后下载Provision Profile文件。 第 5 步 Xcode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。 第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。 相关概念 证书：包含公钥或者私钥，由其他机构对其签名组成的数据包 Entitlements：包含了App权限开关信息 CertificateSigningRequest :本地公钥 p12 : 本地私钥，可以导入到其他电脑 Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。 其他以上的流程是以开发包为例子的，In-house和ad-hoc流程也是大同小异的。 而 AppStore 的签名验证方式有些不一样，前面提到的最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。 据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。 那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。 所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runloop]]></title>
    <url>%2F2016%2F03%2F24%2Frunloop%2F</url>
    <content type="text"><![CDATA[Runloop学习最为一个iOS萌新，一直想弄明白RunLoop这个偏底层的知识点，之前只是大致了解过，但也没搞太明白。最近看了一些讲解RunLoop的文章和视频，在这里作点记录，加深理解。 什么是RunLoop一般来说，一个线程只能执行一个任务，执行完就会退出，如果我们需要一种机制，让线程能随时处理事件但并不退出，那么 RunLoop 就是这样的一个机制。Runloop是事件接收和分发机制的一个实现, 它并不是iOS特有的机制，在 RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。 ###RunLoopMode### runLoopMode可以说是runloop的核心内容，共有4种：source0,source1,observer,timers CFRunLoopTimer NSTimer CFRunLoopSource Source是RunLoopd的数据源抽象类（protocol） RunLoop定义了两种Source Source0: 处理App内部事件、App自己负责管理(触发)，如UIEvent、CFSocket Source1：由RunLoop和内核管理，Mach port驱动，如CFMachPort、CFMessagePort 如有需要，可从中选择一种来实现自动Source ​ UIKit通过RunLoopObserver在RunLoop两次Sleep间对·AutoReleasePool进行Pop和Push，将这次Loop中产生的Autorelease对象释放。 Runloog的应用AutoReleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011 _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西当调用dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS列表页无数据占位图]]></title>
    <url>%2F2016%2F03%2F23%2Fplaceholder%2F</url>
    <content type="text"><![CDATA[在项目开发中经常会碰到页面没有数据展示的情况，如果使用纯白的background给用户的感觉很不好，所以需要有一些占位图来起到提示的作用。比如像下面这样： 之前我们在项目里使用的是DZNEmptyDataSet，很好用的三方，有着和UITableView相似的API，用起来非常方便顺手。 不过还是想要自己实现一下这个功能，下面就是一些思路和实现方式。(以下以tebleview为例，collectionview同理) 核心思路就是：当tableView调用reloadData刷新时，检查tableView行数，如果为零，说明无数据，显示占位图。这里可以使用addSubView或者tableView的backgroundView来添加占位图。 要监测tableView行数是否为0，只需要利用dataSource，用isEmpty来标示是否为空数据，下面是核心代码 1234567891011121314151617181920212223-(void)checkEmpty &#123; BOOL isEmpty = YES; id&lt;UITableViewDataSource&gt; dataSource = self.tableView.dataSource; NSInteger sections = 1; if ([dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) &#123; sections = [dataSource numberOfSectionsInTableView:self.tableView] - 1;//获取当前TableView组数 &#125; for (NSInteger i = 0; i &lt;= sections; i++) &#123; NSInteger rows = [dataSource tableView:self.tableView numberOfRowsInSection:sections];//获取当前TableView各组行数 if (rows) &#123; isEmpty = NO;//若行数存在，不为空 &#125; &#125; if (isEmpty) &#123;//若为空，加载占位图 if (!self.placeholderView) &#123;//若未自定义，展示默认占位图 [self showDefaultPlaceholderView]; &#125; self.placeholderView.hidden = NO; [self.tableView addSubview:self.placeholderView]; &#125; else &#123;//不为空，隐藏占位图 self.placeholderView.hidden = YES; &#125;&#125; 上面这段代码就可以实现当dataSource为空时，为tableView添加占位图的功能。 不过每次都要在控制器里这么写，未免太冗余了，所以还是拿出我们的黑魔法Runtime Method Swizzling 给UITableView添加分类，在分类的+ (void)load方法中，通过Method Swizzling替换reloadData方法，给予它新的实现 123456789101112131415161718192021222324252627+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //方法交换，将reloadData实现交换为checkEmpty_reloadData [self replaceOriginalSEL:@selector(reloadData) withNewSEL:@selector(checkEmpty_reloadData)]; &#125;);&#125;+ (void)replaceSEL:(SEL)originSEL withNewSEL:(SEL)newSEL &#123; Class class = [self class]; Method originMethod = class_getInstanceMethod(class, originSEL); Method newMethod = class_getInstanceMethod(class, newSEL); BOOL didAddMethod = class_addMethod(class, originSEL, method_getImplementation(originMethod), method_getTypeEncoding(originMethod)); if (didAddMethod) &#123; class_replaceMethod(class, newSEL, method_getImplementation(originMethod), method_getTypeEncoding(originMethod)); &#125; else &#123; method_exchangeImplementations(originMethod, newMethod); &#125;&#125; - (void)checkEmpty_reloadData &#123; [self checkEmpty]; [self checkEmpty_reloadData];&#125; 这样就实现了tableView在reloadData的同时检测行数从而判断是否显示占位图的功能。 不过要注意的是，对于UITableView，还需要对endUpdates注入checkEmpty_reloadData方法。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于正则表达式]]></title>
    <url>%2F2016%2F01%2F25%2Fregex%2F</url>
    <content type="text"><![CDATA[iOS正则表达式的运用前言：在大部分app表单填写场景中，都会去校验用户输入的合法性，如果输入有误就提示错误信息并阻止上传到服务器。而这种功能就是由强大的正则表达式来实现的。 1正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 语法正则表达式是由两种基本字符组成：普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符” — metacharacter）所组成的描述文本规则的代码。规则用来描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为文本规则，将某个文本规则与所搜索的字符串进行匹配。 元字符元字符就是指那些在正则表达式中具有特殊意义的专用字符，用来规定其前导字符（位于元字符前面的字符）在目标对象中的出现规则，一个元字符可以用来匹配一个或者多个字符。 总结：元字符就是正则表达式中用来描述一个文本规则的专用字符。举例：精确查找“ab”在未使用正则表达式之前，查找ab，我们可能会得到以下结果 表一：常用的元字符 元字符 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等 \d 匹配数字(0-9) \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 限定符正则表达式中提供了有一类用于限定字符数量的符号，称为 限定符。并且限定符分为两种 ： 贪婪的：尝试尽可能多的匹配元素 惰性（非贪婪）的：尽可能的少的匹配元素 通过添加问号即 ？可以将贪婪限定符转为惰性限定符。从前面的综合例子中，大概已经知道了限定字符数量的字符 例如 ：* ，+，{2}… 表2 常用的限定符 贪婪限定符 惰性限定符 说明 * *? 重复零次或更多次 + *+ 重复一次或更多次 ? ?? 重复零次或一次 {n} {n}? 重复n次 {n,} {n,}? 重复n次或更多次 {n,m} {n,m}? 重复n到m次 正则表达式在iOS中的应用1.NSString的方法 123456- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask&#123;NSString *searchText = @&quot;rangeOfString&quot;;NSRange range = [searchText rangeOfString:@&quot;^[0-9]+$&quot; options:NSRegularExpressionSearch];if (range.location != NSNotFound) &#123; NSLog(@&quot;range ：%@&quot;, [searchText substringWithRange:range]);&#125; 2.NSPredicateCocoa框架中的NSPredicate用于查询，原理和用法都类似于SQL中的where，作用相当于数据库的过滤取。 我们可以编写简单的谓词语句，就可以从数组中过滤出我们想要的数据。 代码示例: 12345+ (BOOL)validateEmail:(NSString *)email&#123; NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex]; return [emailTest evaluateWithObject:email];&#125; 3.NSRegularExpressionNSRegularExpression这个类是苹果专门封装的一个用来处理正则表达式的类。代码示例: 1234567objectivecNSString *searchText = @&quot;you want to match&quot;; NSError *error = NULL;NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&quot;^[0-9]+$&quot; options:NSRegularExpressionCaseInsensitive error:&amp;error];NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];if (result) &#123; NSLog(@&quot;%@&quot;, [searchText substringWithRange:result.range]);&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2015%2F12%2F21%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[LinuxLinux是一套免费使用和自由传播的类Unix操作系统（MacOS也是）。 它的基本思想是： 一切皆文件 除了普通文件，诸如目录、字符设备、块设备、套接字等在Unix/Linux中也都是以文件来对待，虽然类型不同，但是对其提供的却是同一套操作界面。不同的文件根据类型或用途放在不同的目录下。 由目的单一、短小、精悍的程序组成 通过短小、简单的程序保障linux的高效。 文本文件保存配置信息 使用简单的文件编辑器就可以完成配置、更改配置。 尽量避免捕获用户接口 一个程序一旦开始运行，就不需要用户进行任何操作，尽量不和用户交互。 shellshell翻译过来是壳的意思，它是包裹在linux内核外层的，一个可通过一系列的linux命令对操作系统发出相关指令的人机界面。 shell可以通过其条件语句和循环语句等，把一系列linux命令结合在一起，形成一个相当于面向过程的程序—shell script，来实现一些较为复杂的功能。 linux目录操作命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 ------目录的增、删、改、查------ cd, pwd, ls, mkdir, mv, ls(du, df, tree) 切换目录,跟window的使用类似 cd 显示目录的详细信息ls -ld直接切换到根目录cd /在根目录下创建oracle目录mkdir /oraclels -ld /oracledrwxr-xr-x 2 root root 4096 Jun 21 15:00 /oracle 一次创建多个目录mkdir -p /u01/app/oracle显示当前文件夹的路径pwd 删除oracle目录时显示确认rm -r /oracle删除oracle目录时不显示确认rm -rf /oracle把oracle目录名修改成oracle1mv /oracle oracle1把oracle目录移动到/tmp目录下mv /oracle /tmp显示某个目录的详细信息ls oracle -ld相看磁盘空间df -h df /tmp以树形式显示tmp目录的结构tree /tmp查看tmp文件夹下所有文件的路径du /tmp拷贝文件到某个目录cp source dest linux文件操作命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347------文件增，删，改，查------touch, cat, more, less, tail, head, rm -f, mv, cp, vi创建test文本文档touch testvi打开文件模式下，显示行号命令:set number查看test文档的内容cat test查看test文档的内容前10行head -10 test查看test文档的内容最后10行tail -10 test网络登录本地机器ssh localhost实时监控登录信息tail -f /var/log/messagestail -f /var/log/secure分页显示test文本内容，按空格键显示下一页，按q退出more test分页显示test文本内容，按空格键显示下一页，按q退出，按上下键进行上翻和下翻less testtest文件重命名为test1mv test test1把test文件移动到上一级目录下mv test ../把上一级文件test移动到当前目录mv ../test .把test1拷贝成test2cp test1 test2把一个目录拷贝成另一个目录cp -r hh dd删除test1文件并提示是否删除rm test1强制删除test1文件rm -f test1删除当前目录下所有文件rm -rf *备份某个文件cp test test.bak3. vi操作文件常用方式查看模式：G(shift+g) 跳到文件尾部gg 跳到文件首部/ 从文本尾部开始查找某个文本? 从文本首部开始查找某个文本dd 删除一行ndd 删除多行yy 复制一行nyy 复制多行p 粘贴一行或多行u 撤消上一个操作冒号模式 :w 保存:wq 保存并退出:x 保存并退出:q! 不保存退出 :wq! 强制保存并退出 :set number 显示行号编辑模式：a 当前字符的后面插入 i 当前位置插入 o 当前行后面追加一个新行后插入 不同模式之间切换ESC4. linux用户和组操作id oracle 查看用户信息cd /home ls -acat /etc/passwdcat /etc/shodawuseradd oracle 创建oracle用户useradd -u 501 oracle useradd -u 501 -g root oracleuseradd -h 查看useradd命令简略帮助man useradd 查看useradd命令详细帮助， 直接打开帮助文件，q退出usermod -u 502 oracle 修改用户信息usermod -g root oracleuserdel -r oracle 删除oracle用户passwd oracle 修改用户密码cat /etc/group 查看组信息groupadd -g 501 dba 添加组信息groupdel dba 删除组，如果组下面有用户，要先删除用户groupmod -g 502 dba 修改组的giduseradd -u 501 -g oinstall -G dba oracle 给用户添加多个组su - oracle 切换用户并切换用户的配置文件 su oracle 切换用户但不切换用户配置文件权限设置r w x4 2 1rwx r-x r-xuser group others 7 5 5root root otherschown oracle:oinstall /oracle 修改某个目录权限chown -R oracle:oinstall /oracle 修改某个目录及其子目录权限ls -ld /oracle 查看目录权限chmod -R 777 /oracle 设置目录为最大权限chmod -R 755 /oracle 修改oracle目录及其子目录权限为755chown用法用来更改某个目录或文件的用户名和用户组的chown 用户名:组名 文件路径（可以是就对路径也可以是相对路径）例1：chown root:root /tmp/tmp1就是把tmp下的tmp1的用户名和用户组改成root和root（只修改了tmp1的属组）.例2：chown -R root:root /tmp/tmp1就是把tmp下的tmp1下的所有文件的属组都改成root和root。chmod用法用来修改某个目录或文件的访问权限。语法：chmod [who] [+ | - | =] [mode] 文件名 命令中各选项的含义为： 操作对象who可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。 g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。 a 表示“所有（all）用户”。它是系统默认值。 操作符号可以是： + 添加某个权限。 - 取消某个权限。 = 赋予给定权限并取消其他所有权限（如果有的话）。 设置 mode 所表示的权限可用下述字母的任意组合： r 可读。 w 可写。 x 可执行。 X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。 s 在文件执行时把进程的属主或组ID置为该文件的文件属主。 方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。 t 保存程序的文本到交换设备上。 u 与文件属主拥有一样的权限。 g 与和文件属主同组的用户拥有一样的权限。 o 与其他用户拥有一样的权限。 文件名：以空格分开的要改变权限的文件列表，支持通配符。 5. linux软件的安装、解压缩，yum file a.tar.gz*.tartar -xvf a.tartar cvf a.tar a/*.tar.gztar -zcvf a.tar.gz atar -zxvf a.tar.gz*.gzgunzip a.gzgzip -6 a a.gz*.bz2tar -jxvf a.bz2tar -cjvf a a.bz2 *.cpiocpio -idmv &lt; a.cpio*.cpio.gzzcat a.cpio.gz | cpio -idmv*.zipunzip a.zip安装软件rpm -ivh file.rpm过滤安装好的带有zsh字符的软件rpm -qa|grep zsh卸载软件rpm -e file.el5查看所以已安装软件rpm -ga使用yum安装软件mount /dev/hdc /mntcp rhel-debuginfo.repo rhel5.repovi rhel5.repo6. linux主机名、网络配置、网络的查看设置网卡向导setup####################################Name eth0Device eth0Use DHCP []Static IP 192.168.12.100Netmask 255.255.255.0Default gateway IP 192.168.12.1###################################重启网卡/etc/init.d/network restart查看网络配置信息ifconfig ethoifconfig -aip aip add手动修改网络配置文件vi /etc/sysconfig/network-scripts################################################################Inter Corporation 82545EM Gigabit Ethernet Controller (Copper)DEVICE=eth0BOOTPROTO=noneHWADDR=00:0c:29:9e:72:f4ONBOOT=yesTYPE=EthernetNETMASK=255.255.255.0IPADDR=192.168.12.100GATEWAY=192.168.12.1###############################################################修改主机域名vi /etc/hosts##################################################127.0.0.1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6192.168.91.10 RHL5##################################################vi /etc/sysconfig/network########################NETWORKING=yesNETWORKING_IPV6=noHOSTNAME=RHL5GATEWAY=192.168.91.1#######################立即刷新系统设置su -手工修改域名hostname RHL5退出终端，重新打开检查IP是否设置成功ping 192.168.12.100检查域名是否设置成功ping RHL57.linux磁盘管理、存储配置命令（raw配置），多路径软件配置查看各个分区的信息fdisk -l 进入分区模式fdisk /dev/sda让分区操作立即生效partprobe格式化某个分区mkfs.ext3 /dev/sda5把分区mount到某个目录才能使用分区mount /dev/sda5 /mnt取消分区的mount操作umount /dev/sda5把分区映射到某个裸设备, 并增加dba权限cd /etc/udev/rules.dvi 60-raw.rules########################################################ACTION=="add", KERNEL=="sda5",RUN+="/bin/raw/raw1 %N"KERNEL=="raw*", OWNER="oracle" GROUP="dba", MODE="0660"########################################################start_udevraw -qacat 60-raw.rules8.ssh基本操作ssh重启/etc/init.d/sshd restartssh登录到远程机器ssh 192.168.21.100拷贝文件到远程主机某个目录scp -r /oracle 192.168.12.100:/tmp9.linux优化的命令终止指定进程kill -9 11024批量终止xxx进程kill -9 `ps -ef |grep xxx |grep -v grep |awk '&#123;print $2&#125;'`ps -ef |grep ora_ 查看进程df -h 查看磁盘空间free -m 查看内存vmstat 1 5 查看系统统计信息（包括cpu,mem,io等）10.top命令top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2015%2F11%2F09%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[既然是用Markdown写作，必然要了解一下它的语法规则。一开始用会不太习惯，不过相信多加练习用起来应该会比Word顺手很多。下面整理了一些最常用，最基本的Markdown语法。顺便说一下，我用的Markdown编辑器是Typora，非常简洁的一款编辑器，推荐给大家。 标题设置 通过在文字两边加上#，就可以实现标题的效果，两边#号的多少就代表了是几级标题，非常简洁明了，最多可设置六级标题。下面是效果 标题 块注释 通过在文字开头添加&gt;表示块注释。效果如下 ​ 斜体 通过在文字两边加上* 或者_ ， 即可实现斜体效果，如下 斜体 粗体 在文字两边加上**或者__，即可实现粗体效果，如下 加粗 删除线 在文字两边加上~~或者，即可实现删除线效果，如下 删除 行内代码，在文字两边加上”`”，即可实现行内代码效果 code 代码块 “12```代码块 链接: 网址链接：[网址名称]:(具体网址) 图片链接：![图片名称]（具体网址） 效果如下： Baidu 分割线 使用 --- 或者 *** 或者 * * * 表示水平分割线。 表格 使用|…|….|可以显示出表格，效果如下 ….. …. 有序列表 阿拉伯数字后面跟上.和空格，效果就如这篇文章的列表 无序列表 在文字开头添加(*, +, -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。效果如下 第一条 第二条 ​]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
